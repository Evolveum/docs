= Performance Evaluation
:page-toc: top

== Initial Measurements

The setup is as follows:
`TestOperationPerf` creates two users, `alice` and `bob`.
They have five common properties each: `name`, `givenName`, `familyName`, `credentials/password/value`, and `activation/administrativeStatus`.
They have a defined number of single-valued extension properties.
Also, they have a defined number of values in `organization` property, mapped into respective role assignments.

[%autowidth]
|===
| User | Extension properties | Organizations/assignments

| `alice`
| 10
| 3
| `bob`
| 50
| 40
|===

The user logged in was `administrator`, so in fact, no items were removed because of authorizations.
This is the most common case, as usually all tasks and reports are run with full authorization.

There was neither a template nor an archetype to be applied.
The costs incurred were solely from the data traversal and definition wrapping and/or cloning.

We tested three scenarios concerning `applySchemasAndSecurity` method:

. Full updating of both data and definitions (as in 4.7).
. Updating the data, with all definitions switching to transformable ones (to do template/archetype refinements if there were any).
No application of authorizations to definitions.
. Updating the data only.
Definitions were not touched.

The last scenario is not realistic now because we want to refine the schema using templates and archetypes.
But from a performance point of view, it will be the one used because we assume we'll cache the refined schemas.

Each test was run 3 times and consisted of 1,000 calls to `model.getObject` that included (fully cached) H2 repository get operation followed by `applySchemasAndSecurity` one.
Hence, there is an (unknown) common component of the repo call.
But overall, this test provides a basic insight into the situation.

[%autowidth]
|===
| Scenario | `alice` | `bob` | Improvement (`alice`) | Improvement (`bob`)

| Fully updating data and definitions (4.7)
| 13.862 ms
| 14.397 ms
|
|
| Updating data, switching definitions to transformables
| 0.577 ms
| 1.472 ms
| 95.8%
| 89.8%
| Updating data, ignoring definitions
| 0.334 ms
| 0.856 ms
| 97.6%
| 94.1%
|===

image::perf-1.png[Chart]

== Initial Measurements for "No-Autz Definition Update" Approaches

xref:design-meetings.adoc#_2023_04_19[It was decided] that midPoint will _not_ update the definitions, both top-level and at the level of individual items, with the result of authorization processing.
(This was the case of "Full" processing in <<Initial Measurements>> section.)

In order to continue the performance improvements of `applySchemasAndSecurity` method, the more detailed measurements were done.

A low-level `TestPerformance` class in `model-impl` was created that measures the performance of that method in isolation.

The test creates a list of 4,000 user objects, each having:

- 50 single-valued extension properties,
- 51 assignments (1 archetype and 50 roles),
- corresponding values in `archetypeRef` and `roleMembershipRef` items.

The user has an archetype of `person` that is connected with the object template `person`.
The https://github.com/Evolveum/midpoint/blob/b5db18c587dd73b7c3f3f0597275a83117d5f537/model/model-impl/src/test/resources/perf/object-template-person.xml[object template] refines the definitions of 14 items.
Some of them are present in user objects, some are not.
There is a refinement of `assignment/description` that is present 51 times in each user.

The user objects are immutable, as we plan to prefer this mode of operation in the future.

Now the `applySchemasAndSecurity` method is called on the user list.

One test execution consists of a heat-up cycle and then five cycles of "create a list - apply schemas and security".
The time for the schema/security application is summed up and averaged per one method invocation.

There are four authorization scenarios:

. superuser;
. role that can see https://github.com/Evolveum/midpoint/blob/master/model/model-impl/src/test/resources/perf/role-can-read-all.xml[the whole user object];
. role that can see https://github.com/Evolveum/midpoint/blob/master/model/model-impl/src/test/resources/perf/role-can-read-almost-all.xml[almost all the items] (all except one);
. role that can see https://github.com/Evolveum/midpoint/blob/master/model/model-impl/src/test/resources/perf/role-can-read-few.xml[only a few items] (one extension and one assignment property).

We hope that scenarios 1 and 2 will be the usual ones for running reports and other read-intensive tasks.

Concerning the definitions, we run the execution in three modes:

[%autowidth]
|===
| Mode | Description

| Deep
| Schema refinements are executed deeply:
Both in the object-level definition and in lowest item-level definitions (where they are defined).
For example, if `assignment/description` is refined, both object definition and the definitions of individual `description` properties in 51 assignments are modified.
| Root only
| Schema refinements ara executed only in the object-level definition.
| None
| Schema refinements are not applied.
|===

See also experimental https://github.com/Evolveum/midpoint/blob/b5db18c587dd73b7c3f3f0597275a83117d5f537/infra/schema/src/main/java/com/evolveum/midpoint/schema/DefinitionUpdateOption.java[DefinitionUpdateOption] class.

The tests were run three times, with the average values summarized here:

[%autowidth]
|===
| Definitions \ Authorizations | Full | Can read all | Can read almost all | Can read few items

| Deep | 0.600 ms | 0.595 ms | 0.635 ms | 0.474 ms
| Root only | 0.569 ms | 0.560 ms | 0.597 ms | 0.464 ms
| None | 0.200 ms | 0.200 ms | 0.235 ms | 0.206 ms
|===

image::perf-2.png[Chart]

Later, the test was slightly optimized:
The original list (containing immutable objects) was frozen and re-used, so the real test execution is now much faster.
(Creation of test objects, even if done in memory, takes considerable time.)

This had small influence on the performance:

image::perf-2b.png[Chart]

Now, let us concentrate on optimizing the pure authorization application phase, without considering the definitions.
(We suppose this will be the mode in the real operation.)

== Further Improvements

The authorization application was improved in the following stages:

. Baseline: https://github.com/Evolveum/midpoint/commit/e828b741[e828b741]
. Elimination of needless `add` and `modify` authorization decision computations: https://github.com/Evolveum/midpoint/commit/64b6f210[64b6f210]
. Checking if authorization applications would yield any change and optimization of internal data structures: https://github.com/Evolveum/midpoint/commit/604d874d[604d874d]

Now the tests were executed as follows:

. They were run on a separate idle machine (slightly less performant).
. Each test was run 16 times, with two worst and two best times ignored.
. Schema refinements from object template and archetype were not applied - i.e., only authorizations were.
. In order to measure microsecond-level times, the fast tests were executed 20x more times.
Moreover, tests in step 2 and 3 were run with detached (and regularly thrown away) operation result objects to avoid out-of-memory conditions.
This may have a minor influence on the results.
(Testing code for step 2 was back-ported.)

The results are the following:

[%autowidth]
|===
| Version | Commit | Full | Can read all | Can read almost all | Can read few items

| Baseline | https://github.com/Evolveum/midpoint/commit/e828b741[e828b741] | 269.7 µs | 255.9 µs | 284.9 µs | 232.4 µs
| No `add` and `modify` checks | https://github.com/Evolveum/midpoint/commit/64b6f210[64b6f210] | 242.4 µs | 233.2 µs | 264.7 µs | 220.3 µs
| Skip needless autz processing | https://github.com/Evolveum/midpoint/commit/604d874d[604d874d] | 2.9 µs | 3.8 µs | 189.1 µs | 185.6 µs
|===

image::perf-2c.png[Chart]

Just to provide a broader view, we can show a very rough comparison with the `applySchemasAndSecurity` performance in 4.7.
Let's use a conservative estimate of the performance of this method to be ~ 10 milliseconds per user.
(The real value can be somewhere between 10 and 20 milliseconds.)
If needed, the measurements can be done, of course.

[%autowidth]
|===
| Version | Full | Can read all | Can read almost all | Can read few items

| midPoint 4.7 (estimate) |  10,000.0 µs | 10,000.0 µs | 10,000.0 µs | 10,000.0 µs
| https://github.com/Evolveum/midpoint/commit/604d874d[master] | 2.9 µs | 3.8 µs | 189.1 µs | 185.6 µs
|===

image::perf-2d.png[Chart]

The performance improvement is mainly due to the elimination of processing that is currently seen as not strictly necessary:

. tailoring the object definition with authorizations (R - A - M flags) - this made the biggest difference;
. application of template/archetype refinements to the definition;
. simplification of internal data structures;
. using the simplified structures to determine if the authorization application can be skipped altogether.
