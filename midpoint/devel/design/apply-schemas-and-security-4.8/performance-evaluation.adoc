= Performance Evaluation

== Initial Measurements

The setup is as follows:
`TestOperationPerf` creates two users, `alice` and `bob`.
They have five common properties each: `name`, `givenName`, `familyName`, `credentials/password/value`, and `activation/administrativeStatus`.
They have a defined number of single-valued extension properties.
Also, they have a defined number of values in `organization` property, mapped into respective role assignments.

[%autowidth]
|===
| User | Extension properties | Organizations/assignments
| `alice`
| 10
| 3
| `bob`
| 50
| 40
|===

The user logged in was `administrator`, so in fact, no items were removed because of authorizations.
This is the most common case, as usually all tasks and reports are run with full authorization.

There was neither a template nor an archetype to be applied.
The costs incurred were solely from the data traversal and definition wrapping and/or cloning.

We tested three scenarios concerning `applySchemasAndSecurity` method:

. Full updating of both data and definitions (as in 4.7).
. Updating the data, with all definitions switching to transformable ones (to do template/archetype refinements if there were any).
No application of authorizations to definitions.
. Updating the data only.
Definitions were not touched.

The last scenario is not realistic now because we want to refine the schema using templates and archetypes.
But from a performance point of view, it will be the one used because we assume we'll cache the refined schemas.

Each test was run 3 times and consisted of 1,000 calls to `model.getObject` that included (fully cached) H2 repository get operation followed by `applySchemasAndSecurity` one.
Hence, there is an (unknown) common component of the repo call.
But overall, this test provides a basic insight into the situation.

[%autowidth]
|===
| Scenario | `alice` | `bob` | Improvement (`alice`) | Improvement (`bob`)
| Fully updating data and definitions (4.7)
| 13.862 ms
| 14.397 ms
|
|
| Updating data, switching definitions to transformables
| 0.577 ms
| 1.472 ms
| 95.8%
| 89.8%
| Updating data, ignoring definitions
| 0.334 ms
| 0.856 ms
| 97.6%
| 94.1%
|===

image::perf-1.png[Chart]

== Initial Measurements for "No-Autz Definition Update" Approaches

xref:design-meetings.adoc#_2023_04_19[It was decided] that midPoint will _not_ update the definitions, both top-level and at the level of individual items, with the result of authorization processing.
(This was the case of "Full" processing in <<Initial Measurements>> section.)

In order to continue the performance improvements of `applySchemasAndSecurity` method, the more detailed measurements were done.

A low-level `TestPerformance` class in `model-impl` was created that measures the performance of that method in isolation.

The test creates a list of 4,000 user objects, each having:

- 50 single-valued extension properties,
- 51 assignments (1 archetype and 50 roles),
- corresponding values in `archetypeRef` and `roleMembershipRef` items.

The user has an archetype of `person` that is connected with the object template `person`.
The https://github.com/Evolveum/midpoint/blob/b5db18c587dd73b7c3f3f0597275a83117d5f537/model/model-impl/src/test/resources/perf/object-template-person.xml[object template] refines the definitions of 14 items.
Some of them are present in user objects, some are not.
There is a refinement of `assignment/description` that is present 51 times in each user.

The user objects are immutable, as we plan to prefer this mode of operation in the future.

Now the `applySchemasAndSecurity` method is called on the user list.

One test execution consists of a heat-up cycle and then five cycles of "create a list - apply schemas and security".
The time for the schema/security application is summed up and averaged per one method invocation.

There are four authorization scenarios:

. superuser;
. role that can see https://github.com/Evolveum/midpoint/blob/master/model/model-impl/src/test/resources/perf/role-can-read-all.xml[the whole user object];
. role that can see https://github.com/Evolveum/midpoint/blob/master/model/model-impl/src/test/resources/perf/role-can-read-almost-all.xml[almost all the items] (all except one);
. role that can see https://github.com/Evolveum/midpoint/blob/master/model/model-impl/src/test/resources/perf/role-can-read-few.xml[only a few items] (one extension and one assignment property).

We hope that scenarios 1 and 2 will be the usual ones for running reports and other read-intensive tasks.

Concerning the definitions, we run the execution in three modes:

[%autowidth]
|===
| Mode | Description
| Deep
| Schema refinements are executed deeply:
Both in the object-level definition and in lowest item-level definitions (where they are defined).
For example, if `assignment/description` is refined, both object definition and the definitions of individual `description` properties in 51 assignments are modified.
| Root only
| Schema refinements ara executed only in the object-level definition.
| None
| Schema refinements are not applied.
|===

See also experimental https://github.com/Evolveum/midpoint/blob/b5db18c587dd73b7c3f3f0597275a83117d5f537/infra/schema/src/main/java/com/evolveum/midpoint/schema/DefinitionUpdateOption.java[DefinitionUpdateOption] class.

The tests were run three times, with the average values summarized here:

[%autowidth]
|===
| Definitions \ Authorizations | Full | Can read all | Can read almost all | Can read few items
| Deep | 0.600 ms | 0.595 ms | 0.635 ms | 0.474 ms
| Root only | 0.569 ms | 0.560 ms | 0.597 ms | 0.464 ms
| None | 0.200 ms | 0.200 ms | 0.235 ms | 0.206 ms
|===

image::perf-2.png[Chart]
