= LDAP Troubles
Radovan Semančík
:page-toc: top

https://en.wikipedia.org/wiki/Lightweight_Directory_Access_Protocol[Lightweight Directory Access Protocol (LDAP)] is a directory protocol that originated in 1990s.
It is based on older https://en.wikipedia.org/wiki/X.500[X.500] work that goes back even further, into the 1980s.
Nowadays, LDAP is usually used to maintain user accounts in a central directory server.

LDAP is a widely used protocol.
Some (usually older) engineers like LDAP.
And there is a lot to like about it.
It is elegant in its simplicity, it is very efficient, it has pretty much everything that we valued in 1990s.
However, many engineers (usually younger) fear and hate LDAP.
And there is a lot to dislike about LDAP.
Mostly inability of LDAP to correct its mistakes and adapt to a changed world.

This document is a description of LDAP problems.
It is written by an engineer that works with LDAP since late 1990s.
If you work with LDAP, you will quite certainly do not like my point of view.
But deep inside, you know that I am right.

== Authentication

The most common use of LDAP is to enable password-based authentication for applications.
The applications use `bind` LDAP operation to authenticate to the directory server.
If that operation is successful, the application assumes that the password was correct.
There is a wrong way how to implement this authentication (using `dn` pattern) and a less wrong way how to do it (`search` then `bind`).
However, there is no correct way, as LDAP was never designed to be an authentication server.
Yet, this remains the most widespread use of LDAP protocol by far.

Of course, this is causing a lot of problems.
This is limited to password authentication.
Even though there is SASL layer that can support other authentication mechanisms, servers are not equipped to be authentication servers in the first place.
LDAP has no concept of a session, therefore the directory server cannot be used for session management and auditing.
It was never meant to be used in this way.
But it is.

While this is not a problem of LDAP protocol per se, it tells a lot about the LDAP world.
LDAP is used in a way that was not intended and that the original designers never anticipated.
A protocol created in 1990s, with roots in telecommunication world of 1980s, is used to handle 21st century use cases.
It is no wonder it is not very well-equipped for that.


== Account Management

LDAP was never designed to be an authentication protocol.
However, LDAP *was* designed to be a directory access protocol.
Most LDAP servers are in fact directory servers.
A prominent life form in the directory server is a _user account_.
It would be fair to expect that LDAP is an excellent tool for account management.
But it is not.

LDAP schema was inspired by older X.500 data models.
That is perhaps the origin of chronic "multiplicity" of LDAP data structures.
Name of the user is supposed to be stored in `cn` attribute.
The `cn`, as well as `sn`, `givenName`, `uid` and most other LDAP attributes are _multi-valued_.
This makes some sense for `uid`, which usually stores user's login name.
This could be used to support username aliases.
However, even that is far from being perfect.
Yet, this multiplicity makes very little sense for `cn`, `sn` and `givenName`.
Overwhelming majority of deployments are using these in a single-valued form.
And I would bet my lunch that most applications are going to throw ugly errors if they ever encounter more than one value in these attributes.
Why LDAP mandates that these values must be multi-valued?
Strictly speaking, standard-compliant LDAP clients MUST be able to handle multi-valued names.
But how does the client handle it?
LDAP does not guarantee ordering, therefore taking the first value makes no sense.
In fact, there is no good way how to solve this problem.
Therefore vast majority of LDAP clients are not perfectly LDAP-compliant.
Yet, this non-compliance does not make any significant problems in the real world.
You just have to follow unwritten LDAP conventions in addition to LDAP standards.

There are other places of the schema where you can feel the 1980s.
Obviously, there is `facsimileTelephoneNumber` and `telexNumber`, which are a reason for a nostalgic smile.
This may be funny, but it is not a real problem.
The problem is that the schema is not prepared for future development in communication.
There is no concept of contact channels.
There is even no concept of "work phone number".
Not to mention chat applications and social networks.
The schema is frozen in 1990s.

Perhaps the most painful problem is that there is no _account disable_ mechanism.
Yes, there is no standard way how to disable an account in LDAP server.
Most engineers would consider control over account _activation_ to be one of the very basic account management functionalities.
It is certainly much more important than `telexNumber`.
Yet, LDAP does not have it.
This is somehow understandable.
The telecommunication world of 1980s was very different than the world today.
Telex number _was_ much more important than _account disable_ back then.
The problem is, that this was not corrected in 1990s when X.500 was transposed to LDAP.
And it was not fixed up until this day.

Yes, _account disable_ mechanism is needed in practice.
Therefore most LDAP servers have a proprietary mechanism to do that - with a notable exception of OpenLDAP which just does not have it.
However, these mechanisms are proprietary.
Therefore, LDAP clients must use non-standard ways to implement functionality that is needed by almost every deployment.
I can understand and even tolerate lot of LDAP issues.
But I cannot understand this one.


== Groups

LDAP Groups are one of things that are completely wrong.
There is no nice how to put it.
Almost everything that could go wrong went wrong when LDAP grouping mechanism was designed.

Typical LDAP group contains a list of member accounts (or other groups).
This may be an obvious way to design a group schema.
It has some advantages, most notably in simplified access control.
But it is a nightmare from operational perspective.

Common LDAP server has a couple of big groups, groups that almost every account is a member of.
This means that there is an LDAP object that has huge number of values in one attribute.
Adding a member to such a group is very painful.
The operation is usually very slow.
Yet, this is an operation that happens almost every time an account is added or removed.
This happens for every group, as there is no way how to update membership in several groups in one operation.
LDAP servers pride themselves to be lightning-fast.
But what it matters that you can create an account under 1 millisecond, when full provisioning of that account also means assigning it to groups, which literally takes several seconds to complete.

There is a similar problem when determining group membership.
In standard LDAP, the client has to search all groups, looking for a particular member.
LDAP deployments often rely on groups for authorization purposes.
Which means that the client has to make one additional request every time to determine group membership.
Given the presence of big groups, this request may not be entirely fast.

This problem was, of course, recognized quite early.
Therefore almost every LDAP server has a "member of" mechanism that reflects group membership on user entry in a form of virtual attributes.
However, this mechanism is not standardized.
The virtual attribute is `memberOf` in one server, `isMemberOf` in another.
This is yet another non-standard mechanism that is crucial for almost all LDAP clients.

To make the situation entirely bizarre, LDAP standard specifies that group member is a mandatory attribute.
Yes, every group in standard-compliant LDAP server must have at least one member.
It makes no sense whatsoever.
This means that groups cannot be pre-provisioned.
This means that if the last member of the group is removed, the group has to be removed as well.
This also means, that this is not going to work in practice.

Most LDAP deployment work around this in one way or another to make it suitable for real-world deployments.
The deployments that insist on full LDAP compliance usually add fake member to each group.
That works, although your security officer will not entirely happy about it.
The quasi-strict way how to do this would be to add the fake member only to empty groups.
But that will not actually work either.
This means, that every operation that adds a new member must also remove the fake member.
However, due to another LDAP peculiarity (see "permissive modify" below), such operation MUST fail if the fake member is not there.
Therefore the client must first check whether the fake member is there.
However, that check is not reliable, as standard LDAP does not have consistency guarantees to support this case.
The fake member might have been removed in the time before the check and the modify and the modify can still fail.
It is even worse if we try to add fake member to an empty group, however I would like to leave that particular algorithm to the reader to figure out.
All in all, this is how LDAP standard makes a simple thing unbelievably complex.

In fact, the only reasonable way is to ignore LDAP standard and make the member attribute optional.
That is also the way how many LDAP servers do it.
The old iPlanet LDAP server family, which includes (Fedora/RedHat) 389 Directory Server and Sun/Oracle DSEE have optional group member attribute.
As has Sun OpenDS family of servers.
Active Directory family, eDirectory and similar LDAP-like servers opted for their own grouping mechanisms entirely.
Perhaps the only popular LDAP server that still adheres to this insane part of LDAP specifications is OpenLDAP.

Now, the LDAP group saga still does not end here.
LDAP has two object classes for groups, that are entirely the same, except that they are different.
There is `groupOfNames` and `groupOfUniqueNames`.
The former has `memeber` attribute, the later has `uniqueMember` attribute.
That is the only important thing that makes any difference in practical deployments.
Some servers prefer `groupOfNames`, other prefer `groupOfUniqueNames`.
Some applications are hardwired for `groupOfNames`, others required `groupOfUniqueNames` which means that they will not interoperate.
Most applications just resigned to standards and made this configurable.
And then there are other grouping mechanisms, such as `posixGroup`.
Even more grouping mechanisms was proposed or implemented in various LDAP servers in proprietary forms.
LDAP grouping mechanisms would fill a mid-size ZOO and a large lunatic asylum.


== Search, Paging and Sorting

LDAP is lightweight.
In some aspects it is perhaps too lightweight.
There is a very elegant and simple `search` operation, which is a universal tool for data retrieval.
The client usually looks for one particular entry.
LDAP is great for that.
However, long search requests are a big problem.
There is no good way for a client to retrieve a lot of entries.
Why would a client need to retrieve a lot of entries?
Maybe there is a synchronization or reconciliation process that need to make sure that the data are consistent.
There may be an inspection process that checks for policy compliance.
Or we may need to create a report of the data.
Long search operations are needed more often than LDAP authors anticipated.

The simplest option for a long search operation is to use plain LDAP search operation.
However, most directory server will refuse to do that, enforcing "size limit" on number of returned entries.
Even if administrator disables the limit, there are still drawbacks.
The entries are returned sequentially over a single TCP connection.
If that connector is broken, the search needs to be re-started from the beginning.

Then there is "Simple paged results" (SPR) LDAP control (https://tools.ietf.org/html/rfc2696[RFC2696]).
This control can be used to retrieve the results in several requests.
This is a common method how to overcome server size limit.
However, the entries are still delivered sequentially.
With some luck, this could be used to resume a search if the connection is broken.
Although the actual algorithm is not easy and it may not work for every server.
However, this is still very _simple_ paging, e.g. there is no way how to specify starting offset.

Alternative of SPR is https://ldapwiki.com/wiki/Virtual%20List%20View%20Control[Virtual List View] (VLV).
This is a non-standard, but very widely used LDAP control.
It can be used to request particular "page" of the results.
However, there are still many gray zones.
It is not clear what is the impact on the server, as this needs Server Side Sorting (SSS, https://tools.ietf.org/html/rfc2891[RFC2891]) to work reliably.
Therefore, the server usually needs to create temporary data structures that span several requests, and it is not clear how to do that efficiently.
It is quite difficult to create LDAP client that gets the job done and it still nice to the server.

There are at least three approaches for long searches.
SPR and VLV are often supported by servers, but each server has its own peculiarities.
None of these approaches work universally for all the servers.
Therefore it is quite hard to write an interoperable LDAP client.
Which somehow diminishes the value of having a standard in the first place.


== Permissive Modify

LDAP makes updates unnecessarily difficult.
LDAP standard mandates that server MUST fail if client tries to add a value that is already present or remove a value that is not present.
This might have looked good on a drawing board, but it is a disaster in practice.
As LDAP is built with weak consistency in mind, re-adding existing value or deleting already deleted value is a common occurrence.
LDAP data are unordered by design, therefore there are no ordering issues that would prohibit a "permissive" modification.
Yet, LDAP standard explicitly prohibits it.
Which means that standard-compliant LDAP client MUST always check whether a value is present in the entry before modification.
However, such check is not reliable anyway, as there is no guarantee that the entry was not modified between the check and the update.
Therefore there is no good way how to do it.
Even having a special error response that would reliably indicate the problem could make the problem less painful.
But LDAP does not have it.

Similarly to other LDAP problems, this problem is know for a long time.
There is a https://ldapwiki.com/wiki/LDAP_SERVER_PERMISSIVE_MODIFY[Permissive Modify] control that changes server behavior.
It is a part of basic survival kit for many LDAP client authors.
Yes, you guessed it.
This control is not standardized.
Also, it is not supported by all LDAP servers.
In particular, (Fedora/RedHat) 389 Directory Server does not support this control.
Which makes it very painful to work with that server.


== OIDs

X.500 was built with a vision of a world-wide distributed phone book.
Some design decisions of X.500 made sense in that environment.
However, when X.500 was "lightweighted" to LDAP, it took several X.500 concepts that do not fit into LDAP that well.
The concept of _object identifier_ (OID) is one of them.

The original idea was to make OID globally-unique.
Anybody can register its own OID subtree and create unique OIDs for object classes, attribute names, controls and other LDAP creatures.
That would make perfect sense, only if LDAP clients would use `0.9.2342.19200300.100.1.1` instead of `uid`.
Surprise, surprise, engineers tend to like `uid` a bit more than `0.9.2342.19200300.100.1.1`.
Therefore, the OIDs do not really work any more.
They just make the entire LDAP world look quite scary, especially for younger engineers.
In fact, many LDAP servers do not require numeric OIDs at all.
Perhaps the only two things were OIDs are still used are LDAP controls and extensions.


== Replication and Synchronization

Directory servers are built to be lightweight.
The simplicity of LDAP data structures has its benefits.
The servers can provide great performance with low resource consumption.
However, the most important benefit comes from X.500 legacy.
Directory servers are meant to be horizontally scalable, they should work as a distributed system.

As directory servers are in fact just databases, _replication_ capabilities are absolutely crucial for horizontal scalability.
In essence, LDAP has all the prerequisites to be a good foundation for a replicated database.
There is no requirements for ACID properties, consistency guarantees are reasonably low, data models are simple.
However, LDAP standards somehow fail to capitalize on that.

There are replication mechanisms, but almost all of them are proprietary.
There is one "standard" replication protocol (https://tools.ietf.org/html/rfc4533[RFC4533]), but even that is designated as experimental and it is not widely adopted.
Standardized replication would be an ideal method to implement synchronization mechanisms, e.g. to synchronize content of directory system with identity management systems.
However, directory servers provide proprietary, and often inferior mechanisms for synchronization.
This means that every integration of LDAP server synchronization mechanisms is an adventure.


== More

There are few more things:

* Access control lists (ACLs) are used by almost all the servers to control access to entries and attributes.
Yet, the syntax of the ACLs is not compatible.

* Almost all the servers implement password authentication.
Majority of LDAP requests for most servers will be `bind` requests that check the password.
Yet, password policies and lockout mechanisms are different for all the servers.

Most importantly of all, most servers generally deviate from LDAP standards.
For example, 389 Directory Server (and most of the iPlanet family members) allows attributes that contain hash (`#`) in attribute name.
This makes data essentially unportable to other servers.
It even prohibits standard-compliant LDAP clients to interoperate with 389 Directory Server.
Active Directory takes even more liberties.
For example, AD allows any attribute to be set on entries, even if the attribute is not allowed by the schema.
This is nightmare for schema-aware LDAP clients.
Every server has some issues with standard compliance.
As far as I am aware, there is no LDAP server that is 100% standard-compliant.
Which means that standard-compliant LDAP client is a completely useless piece of software.


== Conclusion

There you have it.
You may try to create software that strictly adheres to LDAP standards.
However, such software will be useless.
It is important to know LDAP standards.
But it is even more important to know when to deviate from the standards.
You have to deviate from the standards to survive.

I do not blame the authors of LDAP protocol.
In fact, I have a great respect for them.
They have done their best, back in 1990s.
The fact is that it is not 1990s any longer.
LDAP standards need maintenance.
The standards need major revision and improvements.
That did not happen.
There were some minor updates, some proposals.
No systemic review.

I was discussing these issues with various members of LDAP community during the years.
Unfortunately, there seems to be almost no interest in the community to fix the problems.
I have made my last attempt several years ago.
All my efforts were useless.
Therefore I have decided to stop trying to fix the unfixable.
We have to live with what we have.

LDAP is a legacy technology now.
It has all the characteristics of a legacy technology:
it is flawed, it cannot be fixed, and you need unwritten arcane knowledge to work with it.
Therefore we have to deal with LDAP accordingly to its status.

My recommendation is to consider LDAP specifications to be guidelines rather than actual rules.
LDAP is still useful for many use cases.
However, it is very likely that you need to deviate from the standards to make your solution work.
Welcome to the LDAP world!
