= SCIM Notes

== SCIM Introduction

System for Cross-domain Identity Management (SCIM) is an IETF specification (https://tools.ietf.org/html/rfc7642[RFC7642]) of a RESTful service for identity provisioning.
SCIM specification describes services to create, read, update and delete (a.k.a. "CRUD") data about users and groups.
SCIM services are provided by systems that store identity data, such as applications with their own database, cloud service providers and so on.
SCIM services are invoked by software systems that need to manage the identities.


== SCIM As Universal Interface

SCIM is built on a noble idea to define an universal interface for identity provisioning that every application can use.
This sound like a great idea - and in fact it is.
The problem is that implementing such an interface is much harder than it seems.
This approach was link:/iam/antipatterns/universal-provisioning-interface/[tried many times in the past],
including https://en.wikipedia.org/wiki/Service_Provisioning_Markup_Language[attempts of protocol specification] that were very similar to SCIM.
Such efforts are almost never successful.
In fact such attempts usually introduce additional complexity to the system and result in maintenance nightmares in the long run.
We see people trying the same approach over and over for almost two decades.
The result is always the same.

This seems to be very counter-intuitive.
Creating such abstraction is a well-know and usually very useful architectural pattern.
How it is possible that such a best practice does not work for identity provisioning?
The answer is far from being straightforward, therefore it is perhaps best to illustrate that using a couple of examples.

SCIM specifies a nice schema for the user (account).
Every user should look like this in SCIM notation (simplified):

[source,json]
----
{
  "userName":"jdoe",
  "name":{
    "formatted": "John Doe, PhD.",
    "familyName": "Doe",
    "givenName": "John",
    "honorificSuffix": "PhD."
  },
  "emails":[
    {
      "value":"john.doe@example.com",
      "type":"work",
      "primary": true
    }
  ]
}
----

This looks very nice and sane.
But all the systems are not the same.
Let's have a look at seemingly simple concept of user's name.
Some systems have the name neatly separated to its components such as first name and last name.
Other systems are much simpler and just put everything in one messy string.
SCIM allows variations in the representation of name.
Therefore system `A` returns this:

[source,json]
----
{
  "userName":"jdoe",
  "name":{
    "familyName": "Doe",
    "givenName": "John",
    "honorificSuffix": "PhD."
  },
  ...
}
----

And system `B` returns this:

[source,json]
----
{
  "userName":"jdoe",
  "name":{
    "formatted": "John Doe, PhD."
  },
  ...
}
----

So far so good.
However, the trouble comes when we want to _create_ an account on both system `A` and system `B`.
SCIM has to way to indicate that system `A` needs `familyName` and `givenName` while system `B` needs `formatted` name.

It is perhaps no big deal for system `B`.
SCIM service endpoint may be smart enough to accept both forms of the name as it is easy to format full name from its components.
But what should poor system `A` do if it gets formatted name such as `Hrabě Felix Teleke z Tölökö`.
Which part is first name, which is last name, where is the middle name and which parts are honorific titles?
The client that sends just the formatted name is fully SCIM-compliant, as SCIM schema allows this.
The service `A` is also fully SCIM-compliant.
Yet they cannot interoperate.
The correct behavior needs to be configured or hardcoded in the client.
Which makes interoperability quite difficult to achieve.

You may think that this is not really a problem.
And in fact you may be right, given the common IDM practices of today's world.
People are used to the fact that integration with every new system is a slow and painful process.
But SCIM is not supposed to work just for today.
SCIM was supposed to be an improvement.
But it is not yet there.

This particular problem is perhaps not so bad when it comes to user's name.
Getting the name right is going to require interaction with the user anyway.
But the same problem permeates entire SCIM schema.

Is password required to create new user?
How should we encode/hash the password?
What about user activation status (is user enabled or disabled)?
Does the service support activation at all?
Which values are valid?
Just `true`/`false`?
Is there any way to indicate an archived account?
What about activation dates (valid from, valid to)?
Those are the necessary minimum for even a simple identity management solution.
But SCIM does not have the answers.

All of that boils down to interoperability - or rather lack of it.
SCIM client needs to know a lot of out-of-band details about the service for that specific deployment to work.
The consequence is that vast majority of practical SCIM clients are developed to work with a particular service and they work only with that service.
They are not portable to other services.
They are not interoperable.
This is not really what one would expect from a standard protocol, is it?

Of course, SCIM can be improved.
Future SCIM versions may provide a means for a service to expose the information that the client needs.
But that is where all the ideas of _universal identity provisioning interface_ get really complex.
There is plethora of combinations of service capabilities, password formats, activation options and entitlement schemes.
Fully-compliant SCIM clients will need to support them all.
Which will effectively turn them into identity provisioning systems.

== Issues, Issues and Issues

SCIM is in its second version now and there are talks about a third revision.
There were two SPML versions before SCIM and a handful of provisioning protocols before that.
Those attempts go back for almost two decades.
SCIM has a lot of previous failures to learn from.
Therefore it is quite a big surprising how many issues still remain deeply embedded in SCIM.

SCIM has a prefabricated concepts of _user_ and _group_.
It is almost unbelievable that group membership is controlled by `members` attribute of a group.
This is a well-known approach that goes back (at least) to 1990s.
This approach is so well known especially because it is almost always very problematic.
Majority of deployments have groups that contain pretty much every user in the organization.
Which means that now we have a `Group` SCIM object that has many values in its `members` attribute.
Groups with thousands to millions users are not that rare any more.
Imagine how the SCIM client lists groups with that many members, how long the SCIM response is going to be.
There is a workaround to request all group attributes except `members`, which is something that a reasonable client always wants to do.
However, `members` attribute still needs to be used for group modification.
Which means that both the client and service has to be implemented very carefully to avoid performance issues.
It would be all so much easier if `groups` attribute of the user was used instead.
Or even better: if group mechanics was just a special case of some well defined entitlement or role management mechanism.
Which leads us to `entitlements` and `roles` attributes of the user, which are mentioned, but not really defined.
SCIM leaves a lot to be desired here.

There are lot of smaller issues that make it hard to use SCIM for serious business.
There is no good way how to indicate that user has a password without revealing information about the password (e.g. its hashed value).
However, this functionality is often needed, e.g. if we want to set a password for a user but only if the user does not have a password yet.
Username is mandatory and it has to be globally unique within a service.
However, the username may be generated by the service to ensure the uniqueness.
But in that case the username may not be present in the create operation, which is somehow in conflict with the fact that username is required.
Global uniqueness of username may also be a problem for multi-tenant systems.
Such systems have to use workarounds, such as introducing internal structure to the username.
And some systems may not need username at all.
SCIM forces such systems to duplicate the `id` into username.
Which is also link:https://wiki.evolveum.com/display/midPoint/ICF+Issues#ICFIssues-Schema[an anti-pattern].

There are more issues, but it perhaps makes no sense to enumerate them all.
The big picture should be quite clear now.
Those issues may be caused by the way how many protocols are developed nowadays.
Many protocols are developed _during_ standardization process, not before the process.
Therefore there is not enough time and opportunity to validate the protocol by using it in diverse real-world scenarios.
SCIM obviously suffers from this _premature standardization_ problem.


== SCIM Future

There was SPML once.
It is dead now.
Then there was SPML2.
That one is dead too.
(And no, XML was not the primary reason for SPML failure.)
SCIM has a really tough act to follow here.

SCIM is undoubtedly an improvement over SPML.
SCIM _is_ better.
But that is not the question.
The question is whether SCIM is _good enough_.
And in the state that SCIM is now, it is not good enough.

SCIM may be a good start.
But it is just a start.
It needs major improvements.
It has to be cleaner, richer and more dynamic.
But there is a significant price to pay to get such things.
There will be new complexity.
A lot of complexity.
Therefore forget about simple universal SCIM clients.
The clients will be either simple or universal.
But not both.


== Pragmatic Look At SCIM

Despite all that was said so far, SCIM can still be useful.
It just needs to be used reasonably, one needs to be aware of the limitations and set the expectations right.
Our recommendations:

* If you are just starting, it may be a good idea to start with SCIM.
It is better to start with SCIM than to reinvent everything - especially if you are new to identity management.
Identity management is much more complex that it seems.
Chances are that you end up with something much worse than SCIM if you try to do it your way.

* Do not expect that SCIM will solve all your problems.
Do not expect that your service will be accessible by any SCIM client.
It won't.
You will need spacial client that can be _based_ on SCIM.
But you need to develop that yourself.
Do not expect that your client can access any arbitrary SCIM service.
It won't.
You have to adapt your client for every new service.
In fact, expect that practical interoperability is going to be really low.
However, it may still be better to use SCIM instead of building a service or client on a green field.

* Do not use SCIM groups if you can avoid it.
The way how SCIM deals group membership is a well-known anti-pattern and it is bound to cause a lot of problems sooner or later.
Create your own entitlement mechanism instead.

* It is probably not worth the effort to migrate your existing identity provisioning interface to SCIM.
Unless your identity provisioning interface is really primitive, you are going to struggle to make SCIM do what you need it to do.
You will need to create a lot of custom SCIM extensions.
You will need to change the behavior.
You will most likely end up violating SCIM specifications anyway.
The benefit of migration is that people that it will be easier to understand your API for people that have seen a SCIM interface before.
But they will need to understand your custom extensions anyway and they will almost certainly need to write custom client code.
You have to decide for yourself if such benefit is worth for your specific case.

As long as you are aware of all the limitations of SCIM and it still satisfies your needs it is perhaps OK to use SCIM.
SCIM limitations are not the primary problem with SCIM.
Every technology has limitations.
The big problem is that there are massively inflated expectations about SCIM.
Lot of engineers with a limited experience in identity management see SCIM as a silver bullet.
But it is not.
It is just an ordinary technology.

== SCIM In MidPoint

We do not use SCIM in midPoint, not directly anyway.
There are many reasons for this.

MidPoint is older than SCIM.
MidPoint already has rich API when SCIM was just being developed.
Our API is much richer that SCIM, it is build for dynamic environment and it has more features.
Adopting SCIM as our API would be a significant downgrade.

Clever reader will notice that midPoint has a user schema that is _very_ similar to SCIM schema.
The reason is that midPoint schema and SCIM schema are based on the same VCARD specification.
However, even though the schemas are similar, they are not the same.
SCIM and midPoint schemas are not directly compatible.

Of course, we can create a SCIM interface _in addition_ to our regular interface.
But in that case we will need to maintain and support two interfaces instead of one.
Which is not a negligible effort.
In addition to that, it is very likely that SCIM will go through the usual hype cycle.
Which means that people will start using the limited SCIM interface instead of our full-featured API.
Then we will get a lot of request to extend SCIM functionality to support all midPoint features.
We will have to make hacks and workarounds to expose such functionality using SCIM.
Which means that we will spend a lot of effort to get to the same place where we already are.

There are third-party efforts to create a SCIM proxy for midPoint API.
But there is no practical result so far.

MidPoint supports SCIM indirectly.
There is a couple of SCIM-based connectors for some services.
And we expect that we will develop more such connectors in the future.
However, we have no universal SCIM connector and it is very unlikely that such a connector will ever be possible or practical.
Just look at LDAP.
LDAP exists since 1993.
It is one of the most established and stable protocols that we have in the entire IAM field.
Yet, our "universal" LDAP connector has to account for many peculiarities of every individual LDAP server.
And we have a separate connector for Active Directory, even though the connector is still using LDAP for communication.
It is almost certain that we will need to adopt similar approach for SCIM.

== This Is All Wrong!

__
This Is All Wrong!
SCIM is a standard!
And you should behave and support the standards.
Come on!
Implement SCIM service in midPoint.
Now!
__

Well, technically, SCIM is an informational RFC, not a standard.
But even if it was a standard, what is a values of a standard if it does not really work?
We believe that the primary reason for having standards is _interoperability_.
And SCIM is not doing incredibly well on that front.

However, we admit that we may be wrong with our assessment of SCIM.
In that case please contact us and let us know what exactly we have got wrong.
We will fix it.

We may even reconsider our approach to SCIM support in the future.
But there are two conditions:

. SCIM has to mature.
There are many improvements that needs to be done in SCIM for it to become useful.

. There needs to be a significant incentive.
Funding needs to be secured for both development and _maintenance_ of SCIM interface.
Or there needs to be significant demand from midPoint subscribers.
Hype is not a significant motivation just by itself.
