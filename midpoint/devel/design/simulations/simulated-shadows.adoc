= Shadows in "Simulation Mode"
:page-since: 4.7
:page-toc: top

Not all shadows are equal.

Some are production, others are non-production (simulated, temporary, preview, or whatever terms we will create for them).
They differ in behavior, and that depends on the configuration of the respective object class or object type, and the overall execution mode.

== Uses

. Representing existing resource objects covered by non-production configurations.
This means that the whole resource or its part (object class, object type) is in non-production mode.
See <<Discovered Simulated Shadows>>.

. Representing objects "to be created" on a resource by simulation tasks.
This means that if a simulation is going to create an object on a resource (regardless of whether a production or a non-production one), the operation will not reach the resource, but only a shadow will be created.
This is somewhat similar to resources in maintenance mode.
See <<Created Simulated Shadows>>.

// == Basic Principles
//
// When thinking about the behavior of shadows in a simulation mode, there are some basic principles to maintain:
//
//
// . _Shadows for existing resource objects should be safe to be created and updated._
// +
// The creation or updating of a shadow is not considered to be a "substantial side effect" of any operation in simulation or production task.
// The reason is that this is equivalent to simply browsing the resource.
//
//
// AKA "The mere existence of a shadow is not considered to be a 'visible side effect'"
// AKA "attributes, OCs, exists and dead flag may be updated regardless of the mode"
//
// // limitacia: zmeny v scheme a inych nastaveniach nepodporujeme ako simulovane
// // primarny ciel:
// //   simulovat
// //    - mappingy
// //    - linkovanie
// //    - klasifikacia ?? moze mat obmedzenia, napr. nie reklasifikovanie
// //    --> nezaujima nas az tak moc korelacia, lebo ta samotna je uz dnes bez side efektov

== Task Execution Modes

A task can execute in one of the following modes:

.Potential task modes
[%autowidth]
[%header]
|===
| Mode | Effects | Configuration used | Description

| production
| persistent
| productionfootnote:[e.g. `active` and `deprecated` states]
| This is the standard mode.

| "production simulation"
| non-persistent
| production
| This is the usual "preview changes" mode, when e.g. operation wants to see what effects a particular data change will have, before it's really executed.

| "development simulation"
| non-persistent
| developmentfootnote:[e.g. `proposed` and `active` states]
| Used for fine-tuning and testing proposed configuration changes before they are put into production.
|===

=== Golden Rule

A task running in production or production simulation mode (or production-like mode for short) should ignore all non-production parts of the configuration.

For example, if a resource is marked as "proposed", all of its synchronization-related configuration (reactions, mappings) is treated as non-existent in production-like mode.
Similarly, if an object class marked as "proposed", all synchronization reactions and mappings for all object type definitions based on this object class are treated as non-existent.
Finally, the same is true if a specific object type is marked as "proposed".

[NOTE]
====
This is a slight deviation from the idea that "what is marked as non-production, is considered to be non-existent".

For example, let us assume we have two account types (`normal` and `admin`), while the former is "active" and the latter is "proposed".
Under the current approach, tasks in all modes classify the shadows in the same way.
The shadows marked as `testing` will be "inactive" in the production mode - no synchronization reactions, no mappings.
But it will be classified as such.

In contrast, the original idea (more ambitious but definitely less clear) somehow expected that midPoint would pretend that the `admin` type does not exist at all.
However, we were not able to present a consistent model of midPoint working under these assumptions.

As a practical consequence, we will (currently) not directly support the process of changing a classification code that was already put into production.
The classification code will have to be fine-tuned while the whole resource or the whole object class is in development mode.
====

== Discovered Simulated Shadows

After thorough consideration, it looks like the status of discovered shadows can be determined simply by looking at the status of their object type (given by the kind and intent).
This means that we - for the time being - do not need any special "simulation" flag for them.

Let us now consider the behavior of these shadows under various conditions or actions.

=== Shadows Creation

In all task modes, shadows for newly discovered objects will be created in the same way.
Just like to was from the beginning of midPoint.
Their behavior will be later influenced by the production/non-production status of their object type.
(See below.)

=== Shadows Update

By updating a shadow we mean updating stored identifiers or other cached attributes, object class(es) information, and the like.
Production and non-production configurations should not differ in substantial things, like what identifiers are there, attribute types, attribute caching.
Therefore, we may safely update the shadow in all situations.

NOTE: Practical limitations that stem from these assumptions should be carefully described.

#TODO# It seems that associations may influence the identifiers that are stored in the shadow, see `ProvisioningUtil.shouldStoreAttributeInShadow` and `ShadowCreator.createShadowForRepoStorage`.
We believe this will not have any negative effect.

=== Shadow Classification

.Shadow classification
[%autowidth]
[%header]
|===
| Task execution mode \ Situation | Production type | Non-production type | No type
| Production-like | skip | skip (see note) | execute
| Simulation | skip | re-execute | execute
|===

Note: We keep the non-production classification in the production-like mode, because we don't want the production operation to destroy the results of the previous simulation.

=== Correlation

By correlation, we mean determining the owner (if any).
The actual owner linkage is considered below in <<Synchronization>> section.

.Correlation
[%autowidth]
[%header]
|===
| Task execution mode \ Situation | Has owner | No owner (production type) | No owner (non-production type)
| Production-like | skip | execute | skip (see note)
| Simulation | skip 2+| execute
|===

Note: We skip the correlation for non-production types in production-like modes mainly because of the Golden rule.
In addition, we do not want to destroy the results of the latest simulation by a production-grade operations.

NOTE: Again, this is considered to be a known limitation of the simulations feature.
Later, we will need to provide a process of fine-tuning correlation rules once they were put into production.

=== Synchronization

.Synchronization
[%autowidth]
[%header]
|===
| Task execution mode \ Situation | Production type | Non-production type
| Production-like | execute | skip (see note)
| Simulation 2+| execute in the simulated mode
|===

Note: Per the Golden rule, there is no visible synchronization configuration there.

// Imagine a shadow is seen in a task (produ)
// [%autowidth]
// [%header]
// |===
// | Feature / Situation | Production type in PT | Production type in SMPC task | Production type in SMSC task | Non-production type in production task | Non-production type in SMPC task | Non-production type in SMSC task
// | Updatefootnote:[] when resource object is seen
// 6+| yes^a^
// | Classification | if not | ?^b^ | never | always^c^ |
// | Correlation | if no owner | if no owner | if no owner | if no owner | 2
// | Synchronization | full | ?? | ?? | none | 3
// |===
//
// Notes:
//
// .
// . The algorithm of correlation (i.e. determining the shadow owner) is the same for both kinds.
// . However, even if the owner for a non-production shadow is determined, the linkage will _not_ occur.
// #TODO is this OK? Think again!#

// === Updating the Shadow Mode
//
// * It is done in `ShadowManager.updateShadowInRepository` method, i.e.
// ** after successful on-resource `getObject` operation,
// ** during processing of the object found (`ShadowedObjectFound`),
// ** during processing of the change (`ShadowedChange`).
//
// WARNING: Although the usual change here is from non-production to production mode, nothing prevents a shadow from being switched from production back to non-production.
// #Are we OK with that? What if the shadow has already an owner?#

== Created Simulated Shadows

Shadows that are created by simulation tasks (either with production or development configuration) must not reach the resource.
They will behave like if the resource was in maintenance mode.

We want them to be quickly and safely deleted, for example when a simulation is going to be re-run (and wants to start from zero), or before the resource is put into "active" mode.

So there will be a flag to identify them.

== Side Effects of Provisioning Operations

#TODO this part has not been reviewed yet#

=== Getting the Shadows

==== Regular Mode
. Quick or full shadow refresh - before the GET issued against resource (or after the repo load if noFetch is set).
Arbitrary pending operation can be executed. The shadow may be even deleted by the refresh.
. Discovery process (an event is sent to the listener, typically to model).
. Shadow is updated with the information obtained from the resource:
- cached identifiers and/or other attributes,
- `dead` and `exists` properties,
- (anything else?)
. ...

==== Preview Mode
. No refresh, no execution of pending operations.
. No discovery
. What if we simply not updated the shadow if it is a production one?
