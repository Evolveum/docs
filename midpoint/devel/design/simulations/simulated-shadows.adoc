= Shadows in "Simulation Mode"
:page-since: 4.7
:page-toc: top

Not all shadows are equal.

Some are production, others are non-production (simulated, temporary, preview, or whatever terms we will create for them).
They differ in behavior, and that depends on the configuration of the respective object class or object type, and the overall execution mode.

== Uses

. Representing existing resource objects covered by non-production configurations.
This means that the whole resource or its part (object class, object type) is in non-production mode.
See <<Discovered Simulated Shadows>>.

. Representing objects "to be created" on a resource by simulation tasks.
This means that if a simulation is going to create an object on a resource (regardless of whether a production or a non-production one), the operation will not reach the resource, but only a shadow will be created.
This is somewhat similar to resources in maintenance mode.
See <<Created Simulated Shadows>>.

// == Basic Principles
//
// When thinking about the behavior of shadows in a simulation mode, there are some basic principles to maintain:
//
//
// . _Shadows for existing resource objects should be safe to be created and updated._
// +
// The creation or updating of a shadow is not considered to be a "substantial side effect" of any operation in simulation or production task.
// The reason is that this is equivalent to simply browsing the resource.
//
//
// AKA "The mere existence of a shadow is not considered to be a 'visible side effect'"
// AKA "attributes, OCs, exists and dead flag may be updated regardless of the mode"
//
// // limitacia: zmeny v scheme a inych nastaveniach nepodporujeme ako simulovane
// // primarny ciel:
// //   simulovat
// //    - mappingy
// //    - linkovanie
// //    - klasifikacia ?? moze mat obmedzenia, napr. nie reklasifikovanie
// //    --> nezaujima nas az tak moc korelacia, lebo ta samotna je uz dnes bez side efektov

== Task Execution Modes

A task can execute in one of the following modes:

.Potential task modes
[%autowidth]
[%header]
|===
| Mode | Effects | Configuration used | Description

| production
| persistent
| productionfootnote:[e.g. `active` and `deprecated` states]
| This is the standard mode.

| "production simulation"
| non-persistent
| production
| This is the usual "preview changes" mode, when e.g. operation wants to see what effects a particular data change will have, before it's really executed.

| "development simulation"
| non-persistent
| developmentfootnote:[e.g. `proposed` and `active` states]
| Used for fine-tuning and testing proposed configuration changes before they are put into production.
|===

=== Golden Rule

A task running in production or production simulation mode (or production-like mode for short) should ignore all non-production parts of the configuration.

For example, if a resource is marked as "proposed", all of its synchronization-related configuration (reactions, mappings) is treated as non-existent in production-like mode.
Similarly, if an object class marked as "proposed", all synchronization reactions and mappings for all object type definitions based on this object class are treated as non-existent.
Finally, the same is true if a specific object type is marked as "proposed".

[NOTE]
====
This is a slight deviation from the idea that "what is marked as non-production, is considered to be non-existent".

For example, let us assume we have two account types (`normal` and `admin`), while the former is "active" and the latter is "proposed".
Under the current approach, tasks in all modes classify the shadows in the same way.
The shadows marked as `admin` will be "inactive" in the production mode - no synchronization reactions, no mappings.
But they will be classified as `admin`.

In contrast, the original idea (more ambitious but definitely less clear) somehow expected that midPoint would pretend that the `admin` type does not exist at all.
However, we were not able to present a consistent model of midPoint working under these assumptions.

As a practical consequence, we will (currently) not directly support the process of changing a classification code that was already put into production.
The classification code will have to be fine-tuned while the whole resource or the whole object class is in development mode.
====

== Discovered Simulated Shadows

After thorough consideration, it looks like the status of discovered shadows can be determined simply by looking at the status of their object type (given by the kind and intent).
This means that we - for the time being - do not need any special "simulation" flag for them.

Let us now consider the behavior of these shadows under various conditions or actions.

=== Shadows Creation

In all task modes, shadows for newly discovered objects will be created in the same way.
Just like to was from the beginning of midPoint.
Their behavior will be later influenced by the production/non-production status of their object type.
(See below.)

=== Shadows Update

By updating a shadow we mean updating stored identifiers or other cached attributes, object class(es) information, and the like.
Production and non-production configurations should not differ in substantial things, like what identifiers are there, attribute types, attribute caching.
Therefore, we may safely update the shadow in all situations.

NOTE: Practical limitations that stem from these assumptions should be carefully described.

#TODO# It seems that associations may influence the identifiers that are stored in the shadow, see `ProvisioningUtil.shouldStoreAttributeInShadow` and `ShadowCreator.createShadowForRepoStorage`.
We believe this will not have any negative effect.

=== Shadow Classification

We have a resource object, combined with a shadow that is (currently) either unclassified, or classified as type `T`.
The classification is now done based on the status of `T`.
(_Not_ on the classification of the resource object, as if it would be (re)classified now.)

.Shadow classification
[%autowidth]
[%header]
|===
| Task execution mode \ Situation of `T` | Production type | Non-production type | No type
| Production-like | skip | skip (see note) | execute
| Simulation | skip | re-execute | execute
|===

Note: We keep the classification of non-production objects in the production-like mode, because we don't want the production operation to destroy the results of the previous simulation.

#TODO# Is that OK?
Note that when displaying the content of a resource in development with the hope of showing updated classification, the search must be done in simulation mode.

=== Correlation

By correlation, we mean determining the owner (if any).
The actual owner linkage is considered below in <<Synchronization>> section.

.Correlation
[%autowidth]
[%header]
|===
| Task execution mode \ Situation | Has owner | No owner (production type) | No owner (non-production type)
| Production-like | skip | execute | skip (see note)
| Simulation | skip 2+| execute
|===

Note: We skip the correlation for non-production types in production-like modes mainly because of the Golden rule.
In addition, we do not want to destroy the results of the latest simulation by a production-grade operations.

NOTE: Again, this is considered to be a known limitation of the simulations feature.
Later, we will need to provide a process of fine-tuning correlation rules once they were put into production.

=== Synchronization

.Synchronization
[%autowidth]
[%header]
|===
| Task execution mode \ Situation | Production type | Non-production type
| Production-like | execute | skip (see note)
| Simulation 2+| execute in the simulated mode
|===

Note: Per the Golden rule, there is no visible synchronization configuration there.

// Imagine a shadow is seen in a task (produ)
// [%autowidth]
// [%header]
// |===
// | Feature / Situation | Production type in PT | Production type in SMPC task | Production type in SMSC task | Non-production type in production task | Non-production type in SMPC task | Non-production type in SMSC task
// | Updatefootnote:[] when resource object is seen
// 6+| yes^a^
// | Classification | if not | ?^b^ | never | always^c^ |
// | Correlation | if no owner | if no owner | if no owner | if no owner | 2
// | Synchronization | full | ?? | ?? | none | 3
// |===
//
// Notes:
//
// .
// . The algorithm of correlation (i.e. determining the shadow owner) is the same for both kinds.
// . However, even if the owner for a non-production shadow is determined, the linkage will _not_ occur.
// #TODO is this OK? Think again!#

// === Updating the Shadow Mode
//
// * It is done in `ShadowManager.updateShadowInRepository` method, i.e.
// ** after successful on-resource `getObject` operation,
// ** during processing of the object found (`ShadowedObjectFound`),
// ** during processing of the change (`ShadowedChange`).
//
// WARNING: Although the usual change here is from non-production to production mode, nothing prevents a shadow from being switched from production back to non-production.
// #Are we OK with that? What if the shadow has already an owner?#

== Created Simulated Shadows

Shadows that are created by simulation tasks (either with production or development configuration) must not reach the resource.
They will behave like if the resource was in maintenance mode.

We want them to be quickly and safely deleted, for example when a simulation is going to be re-run (and wants to start from zero), or before the resource is put into "active" mode.

So there will be a flag to identify them.

See the following for details:

=== Creating Resource Objects

What if a task asks for a creation of a resource object?

.Resource object creation
[%autowidth]
[%header]
|===
| Task execution mode \ Object type | Production | Non-production
| "production" | real^a^ .2+| exception^b^
| "production simulation" | simulated^c^ ?
| "development simulation" 2+| simulated^d^
|===

Notes:

a. When a production task asks for creation of a resource object for production object type, the object should be created normally.

b. Production-like task should not normally ask for a creation of object on non-production object type.
The mappings are invisible from production mode, so the only way of creating an object there is to provide all the values (directly or via object construction mappings).

c. Production simulation tasks (preview changes, thresholds) may want to create simulated shadows for production object types.
#TODO when/how will these be deleted? Won't they interfere with shadow created from "development simulation" tasks?#

d. We want to pretend resource objects are created, while they are in fact not.

The "simulated" objects creation here means the behavior very similar or equivalent to the behavior of a resource in maintenance mode.
A shadow will be created in midPoint repository, but not on the resource.
The shadow will be marked in a special way, so it can be easily identified and deleted.

=== Modifying Resource Objects

Now imagine a task asks for a modification of a resource object.

Here the situation is more complex:
For production object types, the existing shadow may be "real" or "simulated".

.Resource object modification
[%autowidth]
[%header]
|===
| Task execution mode \ Situation | Production type, real shadow | Production type, simulated shadow | Non-production type, simulated shadow
| "production" | real | exception^a^ .2+| exception^b^
| "production simulation" | exception^c^ | ?^d^
| "development simulation" | exception^e^ 2+| simulation^f^
|===

Notes:

a. This is an unfortunate clash between simulation and reality.
A shadow was created by a simulation (production or development mode) task.
It might be, for example, a group for an org created by the simulation.
Now, a real task creates the org in the repository, and discovers that there is a shadow for that org.
+
#TODO what should we do?
Should we delete and re-create the shadow anew?
Should we avoid finding that shadow in the first place by the production task?#

b. Production-like task should not normally ask for a modification of an object of a non-production object type, just like it should not normally ask for a creation of such an object.

c. While one can imagine when a "production simulation" can ask for a creation of a resource object of production type (for example, creating a role "on demand" that, in turn, creates an account for itself), it is less imaginable that such a shadow should be modified.
Or, in other words, such modification should be redirected to the bag of "simulation deltas", and not sent to the provisioning.
+
#TODO what if the delta is important?
Like it changes the identifiers of the shadow?#

d. If the shadow was created by the development simulation, it should not be reused by production simulation.
If it was created by production simulation that it's safe to log a pending modification operation to it.

e. We have no mechanism of inserting a pending delta to a production shadow.
Maybe the safest way is to redirect such a delta to the set of "simulation deltas" just like in note "c" above.

f. We simply put the delta to the shadow, just like the resource was in the maintenance mode.

=== Deleting Resource Objects

#TODO#

== Side Effects of Provisioning Operations

#TODO this part has not been reviewed yet#

=== Getting the Shadows

==== Regular Mode
. Quick or full shadow refresh - before the GET issued against resource (or after the repo load if noFetch is set).
Arbitrary pending operation can be executed. The shadow may be even deleted by the refresh.
. Discovery process (an event is sent to the listener, typically to model).
. Shadow is updated with the information obtained from the resource:
- cached identifiers and/or other attributes,
- `dead` and `exists` properties,
- (anything else?)
. ...

==== Preview Mode
. No refresh, no execution of pending operations.
. No discovery
. What if we simply not updated the shadow if it is a production one?
