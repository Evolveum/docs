= Upgrade and Data Migration in midPoint 4.4 and Beyond (Design Notes)

== Goal

Seamless, mostly automatic upgrades from older midPoint versions to newer midPoint versions.
We assume that there will be changes in schema, configuration changes, changes in default values and so on.
The goal of the upgrade is to:

. Maintain behavior of old version, with a configuration that is valid for new version.

. Provide basic configuration ("initial objects") for features present in new version.

We want to:

* Automate as much of the upgrade process as possible.
Ideally, midPoint should upgrade itself without any need for system administrator intervention.

* In case that any manual steps are needed, inform the administrator before upgrade, ideally while still running on old version of midPoint.
We want to automate this as well.
E.g. running `ninja verify _new-version_` should list all the necessary manual data migration issues.

We will probably not reach this goal in 4.4, but we want to get closer than we are now.

== Approach

The problem can be divided into two parts:

. *Schema progress*.
Schema is changed, behavior is not changed.
We want new version to maintain the same behavior as we had in old version.
However, the configuration schema was changed in the meantime.
E.g. we want to change deprecated configuration property to a newer style of the same property (e.g. property rename).
We want to remove a property that is no longer needed.

. *Configuration progress*.
Schema is the same, behavior is different.
We want new version to enable new features that were not present in the old version.
E.g., we want to add new archetype, and apply it to a subset of existing roles.
We want to add new section (container) to system configuration, to provide baseline configuration for a new feature.

Both parts are changing the data, yet they are changing them in different ways.
In practice, we will need both methods.
In that case the schema progress should be applied first, the configuration progress second.

== Process

New version of midPoint will accept data produced by old version of midPoint.
The data may be provided as an export file (XML, JSON) or a database content.

Common upgrade/migration processes:

. Database. Old midPoint is stopped, new midPoint is installed, new midPoint is started.
Data produced in old version of midPoint are stored in the database.

. Export of data from old version (big XML/JSON file).
Import of the data to a new midPoint version (which has almost empty database).

Ideally, we would like to have some "script" that will conduct the upgrade, make all checks, apply all the changes, make post-upgrade checks, etc.

=== Database Schema Changes

TODO: Apply DDL file to make DB schema changes?
How to automate that?

TODO: "application reindex"? How to indicate that it is needed and execute it as part of upgrade process?

== Schema Progress

Extend the current "migration" mechanism in schema (prism):

* Schema versioning.
The schema needs to know which version it is.
This may be an explicit version annotation in XSD, or an implicit version derived from project (midPoint version).

* Add `transition` to migration structure, specifying how much attention the migration requires from the admin.
Values:

** `automatic`: everything happens automatically, no attention of an admin is needed.

** `manual`: admin needs to take care of everything, but there is still a replacement functionality.

** `dead end`: there is no transition from this functionality, there is no replacement.

* Migration operation needs to be extended with:

** `transformed`: the item was changed in a way that cannot be described declaratively, but midPoint may have an algorithm how to modify the data automatically.
E.g. a string value was split to several constituent fields ("hostname:port" to "hostname" and "port"), hostname was changed to URL and so on.
This can be implemented by midPoint providing a "handler" to prism, handling the data transformation cases.

* Severity specification:

** `suggestion`: This specification is just a recommendation.
Current configuration will work, and we do not plan to remove it anytime soon.
E.g. we want to suggest to use a different method, while the original method still works, but it may be limited or non-optimal.
Upgrade "script" may mention this, but it will not place any special attention to this issue.

** `warning`: Warn that this item is likely to be removed soon, suggesting replacement.
Current configuration will work, but we plan to remove it soon.
This is likely to be used for deprecated items.
Upgrade "script" may ask user to change the configuration to use new method.

** `critical`: Old functionality is no longer available.
Current configuration will not work any more.
Upgrade "script" will probably apply the change without asking.

* Filter.
The migration may specify an optional filter, which can be used to migrate only a subset of objects.
This may be used for a change in schema that affects only some object types.
This can be useful in two cases:

** Data structures (complex types) that are reused at several places.
Removed element may have a replacement in one place where the data structure is used, but may have no replacement in others.
This will not work for all re-used data structures (e.g. AssignmentType), therefore we may need to add a path as well (later).

** Correcting mistakes.
We might have been using the schema incorrectly in some situations.
The filter may be used to pinpoint such situations, and selectively correct them.

== Configuration Progress

WARNING: this is just a rough idea now

Maybe we can create something like "annotated delta" data structure:

* Version in which the change happened

* Description of the change: can be displayed to user, can be used to generate relevant release notes section.
May this be automatically generated from a commit message?

* OID of target object, or filter to handle several objects at once.

* Modifications (item deltas)

Maybe we can do the same for _add_ deltas as well, and completely replace initial objects with annotated deltas.
This will simplify LTS upgrade paths, as we can easily merge the deltas from all applicable feature releases.

As for _delete_ deltas, we can have them, but deleting something during upgrades seems to be too dangerous.
It may be better idea to introduce special _obsolete_ lifecycle state and mark objects doomed to deletion with it.
Then the administrator can review the objects after upgrade and decide to clean them up as a post-upgrade step.

== Misc

It is OK to support automatic upgrades only for Postgres with new repo.

== TODO

* "Progress" is perhaps not a good name

* How to deal with `SNAPSHOT` in schema versions?
E.g. we want to specify that migrations are for version 4.4, but we want to apply them to 4.4-SNAPSHOT code to test it before release.

* Obviously, we still need to decide what to implement in 4.4.
We cannot do much, but we can still do something.
