= IGA Design: Parametric Access
:page-nav-title: Parametric Access

== The Problem

We have file shares, or confluence spaces, or similar resources.
We want to grant access to these resources on several "levels": reader, writer, admin

We do *not* want to create "cartesian" roles such as `Share foo reader`, `Share bar reader`, `Share foo writer`, ...

== The Solution

Import shares/spaces/whatever as services in midPoint.
These will represent the "things" that the person gets access to.

The user will want to select the "thing" first.
That looks natural.
I want access to "marketing files" first, only then I think about read-only or read-write access.

Then the user selects a _relation_ to that thing.
Access levels will be represented as relations: `reader`, `writer`, `admin`.
Default relation can be an advantage here, it allows getting "default" access to share/space without caring about the details (without explicitly selecting access level).

Relations that are available for particular type of service (e.g. Windows shares) can be specified in the archetype.
It is natural that all services that represent windows shares will have `Windows Share` archetype.
The archetype can specify `assignmentRelation`, listing all the applicable relations.
This is a natural mechanism that works in midPoint GUI already.

Special variations of access (e.g. different account setting) can be specified in `orderConstraint` in the inducement.
This can be done either in the "thing" itself (space/share), or in the archetype.

== Thoughts

This is almost the same process used for teams and projects.
I want to be a member of a team/project.
Then I think about having a "community-level" access, full member access, being team manager, etc.
The relation is used in teams/projects as well.

Relations are global.
This can be a problem if we get 1000 different meanings what "reader" and "writer" mean.
This will lead to explosion of relation definitions.
However, the fact that relation is global may also be an advantage.
IDM engineers will probably tend to reuse `reader` relation if such relation already exists - simply because reuse is less work than to specify a new relation.
This could naturally create a semi-standardized vocabulary.
For example, I can easily find out all the systems where I am an "admin" by looking at all my assignments that have `admin` relation.
(Still need to account for non-parametric roles here).

Maybe we can help with this by pre-defining a reasonably rich vocabulary for relations out of the box?

Maybe `orderConstraint` outgrew its name.
Maybe it is not about the order any more, and we should rename it?

How do we evaluate the risk here?
Obviously, being a reader and admin of the same space is vastly different risk.
Also, being a reader of `Public` space is a vastly different risk than being a reader of `Top Secret (burn before reading)` space.
We have to divide the risk to two parts:

* Risk posed by the _content_ of the service (share/space).
This can be specified in the service object.
This is obviously very specific to the content of the space/share, this is going to be different for each share/space.

* Risk posed by _relation_ to the service (reader/writer/admin).
This can be specified in the archetype (in `assignmentRelation`).
It would probably be some kind of "multiplier", a ration that is applied to the risk specified by the space.
Risk of a specific relation is probably be the same for all the services.
E.g. being a reader of any space will produce 50% of the "nominal" risk specified in the service.
Being an admin will produce 300% of the nominal risk.

The overall risk given by a specific assignment is computed from the target of the assignment (in this case a service), and corrected by a multiplier given by the relation.

== Problems

How do we get this to the connector?
We so not have complex attributes yet.
Moreover, this is in fact a complex _membership_ in an entitlement, membership with a parameter.
Do we need to improve ConnId?
