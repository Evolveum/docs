= Vanilla Kubernetes
:page-nav-title: Vanilla Kubernetes
:toc: float-right
:toclevels: 4
:page-keywords:  [ 'insatll', 'kubernetes' ]

{% for v in site.data.midpoint-versions %}{% if v.status == null or v.status == "released" %}{% assign lastReleased = v %}{% endif %}{% endfor %}

This page is related to the midPoint in container context of documentation.
Here will be dedicated samples related to the vanilla kubernetes.

You may be interested in :

* common xref:../[container]  related information +
There is information contains possibilities of customization of the installation.

* xref:./docker/[docker] related information +
Sample configuration related to the docker environment.

[NOTE]
====
Page is under construction.
Please check the page soon for new content.
====

== Prepare to start

When we are starting the environment we have to address few steps to have successful start of application.

* namespace (optional) +
There is native isolation concept in kubernetes to group the objects - namespaces.
Even it is not mandatory we recommend to create the namespace to keep the configuration logically grouped.

* repository +
The repository is the relational database where the midPoint's objects are stored.
At the moment of start the repository have to be available and initiated at least on structure level (tables, indexes, etc.).
The definitions for postgreSQL are delivered with the midPoint container.
Initial objects (the content) will be handled by the midPoint itself if needed.

** Init empty structure +
The midPoint can handle the content of DB.
The structure of the repository have to be prepared in advance.
It can be run explicitly one time before first run.
It can be also the part of Init container as conditional block of the code.

** update structure +
Once you have initialized repository there may be need to update the schema with version change - upgrade.
This is usually one time operation with the upgrade.
The upgrade of database schema not necessarily have to be needed with all the midPoint's release - see the xref:/midpoint/release[] page to check if needed.

* required files on filesystem
** configuration file - config.xml +
There have to be proper content of the *config.xml* to be able to start.
Some part can be set / overwritten via environment variables.
** keystore - keystore.jceks +
The keystore is generated automatically in case it is missing.
If you need any additional content (e.g. certificate to establish secured connection to resource) you have to handle explicitly.

* modPoint home
** volumes +

** access "hidden files" behind the mount points

== Deployment
To start the environment we need several objects.
We can group them by the type / purpose:

* StatefulSet +
Control objects which provide template for the pods including the scale - amount of requested instance.
+
repository definition without persistent storage : link:https://raw.githubusercontent.com/Evolveum/midpoint-kubernetes/main/deployment/statefulset-repository.yaml[statefulset-repository.yaml]
+
midPoint without persistent storage : link:https://raw.githubusercontent.com/Evolveum/midpoint-kubernetes/main/deployment/service-midpoint.yaml[service-midpoint.yaml]

* Service +
"Meeting point" for the use case.
As pods has dynamic IPs there are not available IP addresses in advance.
The service "scan" for the pods with the specific set of the labels (metadata).
Once the match is found the IP is added to the endpoint list for the service.
The name of service is known and it can be used for the connection (e.g. midPoint contact the repository using service definition).
+
repository : link:https://raw.githubusercontent.com/Evolveum/midpoint-kubernetes/main/deployment/service-repository.yaml[service-repository.yaml]
+
midPoint: link:https://raw.githubusercontent.com/Evolveum/midpoint-kubernetes/main/deployment/service-midpoint.yaml[service-midpoint.yaml]

* Ingress +
Entry point for the user.
It is reverse proxy - first point of contact for the communication from outside on shared ports (http - TCP/80, https - TCP/443).
Once the definition match the communication is passed to the defined service.

* _pod_ +
The pods is not defined directly by default.
It is result of the statefulSet definition.

.base object used for the environment
image::kubernetes-diagram.png[]

=== Start the environment

.create / start the environment
[source,bash]
----
kubectl apply -f namespace.yaml -f statefulset-repository.yaml -f service-repository.yaml -f statefulset-midpoint.yaml -f service-midpoint.yaml
----


.start midpoint instance (set replica count to 1)
[source,bash]
----
kubectl scale -n midpoint-deployment --replicas=1 sts/midpoint
----

=== Stop up the environment

.stop midpoint instance (set replica count to 0)
[source,bash]
----
kubectl scale -n midpoint-deployment --replicas=0 sts/midpoint
----

.clean up the environment
[source,bash]
----
kubectl delete -f namespace.yaml -f statefulset-repository.yaml -f service-repository.yaml -f statefulset-midpoint.yaml -f service-midpoint.yaml
----

== Configuration files
For the native repository there is need to have proper configuration for the db connection.
This configuration is stored in *config.xml* located in midPoint home directory.

To have it ready you have several options how to handle it.

* *configmap* mounted to the pod's filesystem
* *secret* mounted to the pod's filesystem
* *Persistent Volume Claim*
* handle it dynamically in the *initContainer*

