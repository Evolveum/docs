= Axiom: Draft

WARNING: This is draft of feature, currently none of described functionality is available.
The language design and concepts are still subject to change.

Axiom is data modeling language designed for Prism.
Design activity is part of link:/midpoint/midprivacy/[midPrivacy] project.


== Syntax

Axiom will use simple syntax which will consists of statements (with arguments),
substatements and concepts.

NOTE: Statement concepts were inspired by YANG modeling language from IETF,
which tries to strike balance between readability and authoring.
(https://tools.ietf.org/html/rfc7950#section-6.3[YANG 1.1: 6.3 Statements])

.Basic ABNF
----
 statement = keyword [argument] (";" / "{" *statement "}")
----

This provides basic simple structure for language and allows for simpler parser (See ANTLR4 syntax bellow.)

The *omission of actual keywords* from grammar allows for addition of keywords
and language extensions without need to change grammar definition (and lexer code).

NOTE: Experience during development and refactor of YANG Parser in OpenDaylight showed
that this simplified form is more flexible and allows for cleaner parsing code
and more user-friendly error reporting.




.Short syntax example
[source,axiom]
----
complexType Address { // <1>
  description "Simple Address Type

    Represents physical address.
    Address should be normalized.
    "; // <2>
  property street {  // <3>
    type PolyString; // <4>
    required; // <5>
    storage:indexed fulltext; // <6>
  }
  // ...
}
----
<1> Complex statement `complexType` with argument `Address`
<2> Statement `description` with multi-line argument (ideal for )
<3> Another complex `statement`
<4> Complex statemetn
<5> Simple statement without argument
<6> Statement `indexed` from extension `storage`



### Examples

[source,axiom]
----
include::examples/polystring.axiom[]
----


### ANTLR4 Syntax

.Axiom ANTLR4
[source,antlr]
----
include::examples/AxiomParser.g4[]
----

Thanks to simple statement model the grammar is simple and most logic (and keyword validation)
is left to runtime.

== Open Questions

* Name conventions: lowCamelCase, UpperCamelCase, kebab-case?

* Model name vs namespace: Do we need unique namespace?
Should model name be globally unique or just locally unique?
Can several models use the same namespace?

* Import: import by model name? By namespace? By file name?

* Prefixes: use prefixes or full namespace?
Won't we get info XML-like prefix nightmares?

* object definition:

** Do we need special complex type definition or does object definition doubles as complex type?

** What to use as parameter of `object` statement? Item name or type name?

* `maxOccurs`,`minOccurs` vs `multiValue`,`optional`,`required`, etc.

* `description`, `documentation` or both? HTML-formatted, asciidoc formatted, or format selection?

* Extensions:

** How to model extensions/mixins, e.g. run-time user schema extension in midPoint

* References:

** `objectReferece` or `reference`?

** What do to with filters and expressions in them?
Filters are perhaps going to be native part of "prism" anyway.
But do they fit into Axiom?
See also expressions below.

** What do to with relation?
Is it generic concept? Or should it be an extension?

** what do to with `resultionTime`?

* Expressions

** Make expression a first-class citizen in Axiom?
This may make some things easier, especially filters and constants.

** We still do not need to specify expression evaluators (e.g. scripting languages).
But how to extend these? Implementation-specific?


* Axiom-in-axiom

** Can we define Axiom in Axiom? Probably we can.

** Reuse extension mechanism to define language binding?
E.g. Java names for types and enumeration values?
