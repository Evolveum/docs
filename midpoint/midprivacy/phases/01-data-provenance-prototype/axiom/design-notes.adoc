= Axiom Design Notes

_Axiom_ is a new data modeling language for Prism and midPoint.
It is developed as part of midPrivacy project.

== Requirements

* Similar basic capabilities than existing schema languages:

** Primitive data types (approx. the level of support of XSD primitive types used by midPoint)

** Complex data types (including support for data types, equivalent to complex types in XSD)

* Insensitive to element ordering

* Extensibility points: ability to extend the data model in runtime.

* Human-readable and preferable human-friendly.

* Optional complex data "keys" instead of current container identifiers.

* ItemPath concept should remain almost the same.

* Support for objects (identified by OID) and object references.

** Tip: think about "RESTifying" the model.
What happens if the data are exposed in REST?
Would it make sense to replace OIDs with URIs/URLs?
Think about _semantic web_ concepts.

* Support for semantic versioning of the model

* Built-in support for lifecycle properties: `since`, `deprecated`, `plannedRemoval`, etc.

* Support for meta-data (e.g. provenance meta-data). Meta-data schema extensible in runtime.

* Support for "rich" primitive types such as polystring and protected string.

* Built-in documentation support (similar to xsd:documentation, but maybe we would prefer asciidoc?)

* Ability to add custom annotations (similar to XSD annotations)

* Idea: consider data lifecycle/retention.
E.g. we have _operational_ data that are computed.
We have meta data that are _transient_ (not stored) and _persistent_ (stored).
Maybe we can somehow merge and generalize those concepts?

* Question: what about data presentation?
E.g. do we want support for human-readable labels for data model items?

* Tip: think about how new query/filter language can be aligned.

* Tip: think about how midPoint bulk action language can be aligned.

* Tip: think about "natural" representation of objects (non-XML/JSON/YAML).

* Nice to have: ability to define itself (such as XSD syntax can be specified in XSD).

=== Data Completeness

We have to distinguish several cases for completeness of data:

* We know that item has values X, Y and Z.
It has no other values.
This is the common case.

* We know that item has no value.
E.g. we are sure that there are no criminal records for this person.

* We know nothing about an item.

* We know that item used to have values X, Y, Z recently.
E.g. values that were removed by a particular mapping.

* We know that the item has some value, but we do not know the value (the value is "unkowable").
E.g. there is a hashed password, we do not even want to disclose the hash, but we want to indicate that the password is already set.

* We know that the item has some, we do not know the value now, but we can easily find out when needed.
E.g. values that are not returned in the query because they are big or expensive.
But we can easily construct a query that requests them explicitly.
Or values, for which we have an expression that can be used to determine them.
But we do not want to execute that expression if the value is not needed.

* We know that the item has value X, but the item may also have other values that we do not know.

Note: we may still want to keep metadata for such values.
E.g. "We are sure that there are no criminal records for this person, we know that with high LOA, and this information is 2 days old".

== Why We Do Not Just Use XSD?

There are many reasons why we do not want to continue using XSD:

* *Element ordering*: It is not very convenient to create schema in which element ordering does not matter.
Prism/midPoint ignored element ordering almost since the beginning because that feature is needed for reliable application of deltas.
It is also much better from ease-of-use point of view.
However, XSD definition required correct ordering.
Which was a problem for validation.

* XSD is *verbose*.
XSD may have nice structure for machine processing.
But it is quite difficult to read and maintain for a human.

* XSD is built especially for *XML*.
It has concepts that do not easily map to other languages, su as attributes.
Overall, XSD is burdened by complexity of the XML world.
It may be OK to simply not use those features.
But then we will need to create dialect of XSD which will not be real XSD any more.

* Over the existence of midPoint we introduced link:../xsd-keywords-use/[large number of XSD annotations], which are used for modeling data and system behaviour.
These annotations are not first-level citizens of XSD, but are necessary for midPoint to work.
Introducing language where most of them would be first-level citizens would simplify model lifecycle and readability.
Which means we have create an XSD dialect already.

* XSD-processing libraries are aging, falling into disrepair and many becoming quite obsolete.
We would gladly contribute and improve the libraries.
However, many of those libraries are based on development project of big corporations that are not very active any more (e.g. Sun Microsystems).
They are open source by name only.
There is no real community around them.
Therefore it looks like there is little perspective in XSD development.

== Why We Do not Just use YANG, JSON Schema or SCIM?

We link:../existing-languages-analysis/[considered several existing languages] for schema modeling in the context of midPrivacy.
Based on our existing experience with using custom XSD annotations in *midPoint* and implementation of *YANG* language in OpenDaylight project.
The result was that none of XSD, YANG, JSON Schema or SCIM meets our requirements, without significant hit on readability, or lot of extensions to extend schema language.
