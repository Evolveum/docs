= Axiom Metadata
:page-toc: float-right

== Example: MidPoint Metadata

Metadata model definition:

[source]
----
model midpoint {
    metadata StorageMetadata {  // Creates type StorageMetadata
        target {
            // apply this metadata for all Prism items
            itemType prism:Item;
        }
        itemName: storage;
        item creation { ... }
        item modification { ... }
    }
}
----

Metadata serialized with data:

.XML, full namespaces
[source,xml]
----
    ...
    <description>
        <axiom:value>Lorem ipsum dolor sit amet ...</axiom:value>
        <axiom:metadata>
            <midpoint:storage>
                <midpoint:creation>...</midpoint:creation>
                <midpoint:modification>...</midpoint:modification>
            </midpoint:storage>
        </axiom:metadata>
    </description>
    ...
----

.XML, minimal namespaces
[source,xml]
----
    ...
    <description>
        <_value>Lorem ipsum dolor sit amet ...</_value>
        <_metadata>
            <!-- We need namespace here to avoid conflicts with other metadata (similar rules than augmentation) -->
            <midpoint:storage xmlns:midpoint="http://.../midpoint">
                <!-- Namespaces are not be strictly necessary inside storage element -->
                <creation>...</creation>
                <modification>...</modification>
            </midpoint:storage>
        </_metadata>
    </description>
    ...
----


.JSON
[source,json]
----
  ...
  "description" : {
    "@value" : "Lorem ipsum dolor sit amet ...",
    "@metadata" : {
        "http://.../midpoint#storage" : {
          "creation" : ....,
          "modification" : ....
        }
    }
  }
----


== Completeness

TODO

Use case: jpegPhoto was not fetched from repository and we do not know whether it has a value or not.

.XML, full namespaces
[source,xml]
----
    ...
    <jpegPhoto xsi:nil="true">
        <axiom:completeness>incomplete</axiom:completeness>
    </jpegPhoto>
    ...
----

.XML, minimal namespaces
[source,xml]
----
    ...
    <jpegPhoto nil="true">
        <_completeness>incomplete</_completeness>
    </jpegPhoto>
    ...
----

There is an issue that the completeness is a property of `jpegPhoto` item, not a particular value.
But we cannot express data about an item if there is no value present.
Hence the `nil`.
The `nil` indicates that this value is not really a value.

.JSON
[source,json]
----
  ...
  "jpegPhoto" : {
    "@value" : null,
    "@completeness" : "incomplete"
  }
----

The `@value=null` may be optional, as this is a hash and no value is specified this should be obvious.

Use case: password is present, but we cannot or do not want to disclose the value.
However, we want to indicate that there is a password.

.XML, full namespaces
[source,xml]
----
    ...
    <password xsi:nil="true">
        <axiom:significance>unknown</axiom:significance>
    </password>
    ...
----

.XML, minimal namespaces
[source,xml]
----
    ...
    <password nil="true">
        <_significance>unknown</_significance>
    </password>
    ...
----

.JSON
[source,json]
----
  ...
  "password" : {
    "@significance" : "unknown"
  }
----


== Prism Expressions

TODO: following definition has to be corrected

[source]
----
model prism {
    infra ValueExpression {
        target {
            itemType prism:Property;
        }
        itemName: expression;
        type: Expression;
    }
}
----

Example data with expression.
`prop123` is a string prism property.

.XML, full namespaces
[source,xml]
----
    ...
    <prop123>
        <axiom:significance>unknown</axiom:significance>
        <prism:expression>
            <midpoint:const>const123</midpoint:const>
        </prism:expression>
    </prop123>
    ...
----

.XML, minimal namespaces
[source,xml]
----
    ...
    <prop123>
        <_significance>unknown</_significance>
        <_expression>
            <const>const123</const>
        </_expression>
    </prop123>
    ...
----

.JSON
[source,json]
----
  ...
  "prop123" : {
    "@expression" : {
      "const" : "const123"
    }
  }
  ...
----

Question: Do we need to set `@significance=unknown` here explicitly?
Or can we infer that from the fact that there is no `@value` here?
We could perhaps do that in JSON.
But XML will still need either explicit significance or `xsi:nil`, because all XMl elements have value (even if it is empty string).
Or can be have XML parsing mode where we ignore whitespace in indent and consider empty string to be null?

== Metadata Of Negative Values

Metadata serialized with data:

.XML, full namespace
[source,xml]
----
    ...
    <description>
        <axiom:value>This was all wrong, it is gone now</axiom:value>
        <axiom:significance>negative</axiom:significance>
        <axiom:metadata>
            <midpoint:transformation>
                <midpoint:mapping>...</midpoint:mapping>
            </midpoint:storage>
        </axiom:metadata>
    </description>
    ...
----

.XML, minimal namespace
[source,xml]
----
    ...
    <description>
        <_value>This was all wrong, it is gone now</_value>
        <_significance>negative</_significance>
        <_metadata>
            <midpoint:transformation>
                <mapping>...</mapping>
            </midpoint:storage>
        </_metadata>
    </description>
    ...
----


.JSON
[source,json]
----
  ...
  "description" : {
    "@value" : "This was all wrong, it is gone now",
    "@significance" : "negative",
    "@metadata" : {
        "http://.../midpoint#transformation" : {
          "mapping" : ....,
      }
    }
  }
----


== Notes

Considered Option: Metadata Definition using Augmentation

Not a good option. Metadata may be too complex to be handled by simple augmentation.
This is also not very readable.

[source]
----
model midpoint {
    augmentation ValueMetadata {
        target axiom:ValueMetadata;  // Magic type
        item storage {
            type StorageMetadata;
        }
    }

    type StorageMetadata {
        item creation { ... }
        item modification { ... }
    }
}
----
