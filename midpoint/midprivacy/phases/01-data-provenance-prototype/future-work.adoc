= Future Work
:page-toc: top

Following open questions, issues and ideas remain unresolved (or partially resolved) after the end of this project phase.
This is a material for potential future work.

== Metadata

=== Metadata Queries And Indexing

Computing metadata is one thing, but storing, indexing and searching the metadata is another thing entirely.
This phase of the project is only partially concerned with storing metadata and it is not concerned with indexing and searching metadata at all.
Indexing and searching metadata brings its own unique set of questions, such as forming queries that refer to metadata.
Axiom item paths can refer _inframodel_ items, therefore metadata can theoretically be referenced in search queries.
However, this aspect was not explored as part of this prototype.
Yet another problem is related to metadata schema.
It looks like the metadata are fundamentally multi-value.
However, common database indexing mechanisms are problematic when applied to multi-value data.
This problem has to be explored in depth.
In addition to that, there may be a concern on metadata storage and indexing overhead.
As metadata can be maintained for every value, the metadata-enriched model may be very large.
Storage and indexing of such a large model may be too expensive.
Therefore it is likely that selective storage/indexing for metadata will be needed.

=== Container Metadata

Metadata for non-complex values can be already quite complicated.
However, there is an additional degree of complexity when considering meta-data of complex (structured) values.
In Axiom/Prism terminology, those are _object_ and _container_ metadata.
Complex values contain another values within them.
For example modification timestamp of an object should be set to the time of the latest modification of any item that the object contains.
This phase of the project did not explore this issues in depth, as there is already a pre-existing mechanism for object metadata maintenance in midPoint.
However, complete metadata solution should focus on this area as well.

=== MidPoint Metadata Compatibility

MidPoint has a pre-existing simple metadata maitenance mechanism that is applied to several selected items.
Due to the compatibility reasons, this mechanism had to be maintained and could not be completely replaced with a new mechanism.
This phase of the project has discovered several interesting incompatibilities.
The multi-value nature of metadata was one of the most interesting discoveries.
It is also perhaps the most troubling one, as many pre-existing systems assume single-value character of metadata.
The single-value character of metadata is assumed by midPoint 4.1 and earlier.
We had to keep compatibility with existing midPoint installations, therefore the pre-existing system cannot be dismantled and relaced.
As of midPoint 4.2, the two systems co-exist side by side.
Further research is needed to align those two systems completely.
The questions that are outlined above are essential for this alignment to be possible.

== Axiom

Axiom has to be further evolved to become (more) mature language.
Using Axiom to define metadata schemas is a great validation of the concepts, especially the _inframodel_ concept.
It is also a validation that basic mechanisms of Axiom language work.
However, there is still a lot to work on for Axiom to become a mature language:

* Support for enumerations.

* Support for ordered data types (lists/arrays).

* Support for heterogeneous multi-valued data structure that may contains mixed elements (a.k.a. "heterolists").

* Make sure that Axiom is "web-friendly" and that it is suitable for building REST-like interfaces.

* Smooth out JSON/YAML syntax.
There are still several alternative notations, e.g. `@ns` or `@context`.
May be worth considering at least partial interoperability with JSON-LD or other JSON variants.

* Final decision on small Axiom language details.
E.g. `minOccurs`/`maxOccurs` vs `required`/`multivalue`.
We are also considering making semicolon optional, as well as quotes around single-word strings.

* Introduction of _dynamic_ data type: data type that can be fully specified at runtime.

* Versioning and deprecation details.
Some versioning concepts are already specified, but the compatibility and deprecation rules for Axiom model versioning are not yet entirely clear.

* Support for custom annotations in Axiom models.

* Deltas: are they native (hardcoded) data structures in Axiom?
Are deltas modeled in Axiom as any other data structure?
Or do deltas rather belong to Prism?

* Decide about query language.
Should it be part of Axiom? Or should it rather belong to Prism?

* Display properties.
Should Axiom specify how a particular item should be displayed (e.g. display name, internationalization, etc.).
Or does this rather belong to Prism?

Major part of future Axiom work would be documentation.
There is Axiom specification, but it is mostly supposed to be reference document.
More documents, such as tutorials, guides and examples will be needed for easier understanding of Axiom concepts.

== Prism Cleanup And Evolution

Prism data library is built on top of Axiom language.
Prism was used in midPoint for many years, but it was built on XSD instead of Axiom.
The XSD was a major limitation.
Switch to Axiom opened up exciting opportunities and enabled further development of Prism.
Such as:

* Solving the _container identifier_ problem.
Multi-value containers need identifiers to properly address each container value (e.g. in deltas).
We have tried to create automatic numeric container identifiers in Prism 3.x with XSD.
Container identifier was transparently assigned by the system, which was supposed to ensure its uniqueness.
However, that did not work well and we were not able to find a satisfactory solution.
As Prism is built with eventual consistency in mind, there were always risks of identifier conflicts.
The solution would be to have application-assigned and perhaps application-meaningful identifiers.
However, that would be quite cumbersome and difficult to use with XSD.
Axiom opens up a possibility for better solution.

* Operational items are set by the system.
They are considered to be read-only for the user.
Operational items often need special handling, e.g. a code that computes them.
Authorizations may ignore operational items in some cases.
Operational items may be stored differently, they may affect data versioning and so on.
We need a clean way how to mark operational items in the model.

* Elaborate items are often too complex for automatic processing.
Ordinary items can be almost always processed by automatic code to render the user interface, to evaluate authorizations and so on.
No special code is usually needed.
But some items are too complex for that, e.g. items that contain recursive data structures.
Usual automatic algorithms fail for such items.
Therefore such items are marked as "elaborate" to avoid automatic processing.

== See Also

* link:../challenges/[Challenges]
* link:../axiom/todo/[Axiom TODO]
