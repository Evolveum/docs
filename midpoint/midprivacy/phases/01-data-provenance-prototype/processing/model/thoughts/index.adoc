= Some thoughts about metadata processing

* link:https://wiki.evolveum.com/display/midPoint/Expression[Expression] for background information on expression evaluation,
* link:../../plain/expressions/[Processing expressions] for information on processing "simple" data expressions,
* link:../../plain/mappings/[Processing mappings] for information on processing "simple" data mappings.

To recall, an _expression evaluator_ converts _sources_ and _input variables_ to _output values_ (under given evaluation parameters).

image::../plain/expressions/expression context.png["Expression context"]

Each value being processed can have its own _value metadata_ and, therefore, we have to process this metadata
along with the data.

Metadata can be present on values from both sources and variables but for the time being we will explicitly
deal with metadata from sources only.

== Where to put metadata support?

*Should the metadata support start at the level of expression, or it is sufficient to support it for mappings?*

The answer depends on whether there are mapping-less expressions that produce values that ultimately end
somewhere in midPoint objects. It seems like there are some:

=== Category 1: Usually covered by "outer" mapping

* `PopulatorUtil.evaluatePopulateExpression` It is called when populating assignment in auto-assignment scenarios,
and also when creating assignments and/or objects in target search expression evaluators. However, the execution of
these expressions is usually done in the context of a mapping.
* `ExpressionUtil.evaluateFilterExpressionsInternal` We use expressions to evaluate filters that might be used
e.g. for target search in other expressions. Values in the filters are not important per se. What is important are
objects that result from these searches. (Like roles when we are searching them by name.) Fortunately, the most probable
context for these filter expression evaluation (that leads to inclusion of some values in objects) is target search
expression i.e. something done in the context of a mapping.

=== Category 2: Generating item values for objects but not executing in a mapping (probably need to process metadata)

* `LensUtil.formatIterationToken` Iteration token itself can contain sensitive information.
* `ObjectMerger` It computes merged values via expressions.

=== Category 3: Generating item values for objects, but probably not requiring metadata processing, at least not now

* `VariablesUtil` - evaluation of variables for bulk actions (can somehow sneak into objects)
* `ScriptingTaskCreator` - customizes scripting task (the task will contain generated values)
* `SynchronizationExpressionEvaluator.createTag` - creates tag for a projection (multi-intents)
* `PerformerCommentsFormatterImpl` - provides approver comments in string form - this is really ugly case but still valid.
* `ClockworkAuditHelper.auditEvent` - values for custom audit columns (not important for now, maybe in the future)
* Individual scripting actions that modify objects using custom values (`execute-script`, `modify`, ...)

So, metadata processing will be declared and executed at the level of mapping evaluation.
But there will be some support from expression evaluators, mainly because of the combinatorial (relative) evaluation
of scripts and other value-transforming expression evaluators.

== How to work with metadata mappings?

=== Data mapping

Data mappings transform source item(s) - e.g. S~A~, S~B~, ..., S~Z~ - to output (target) item - e.g. O - in the
context of a single object.

image::data-mapping-simplified.png["Data mapping (simplified)"]

Each source has some old and new values. Let us denote them a~1~, a~2~, ..., a~na~ ->
a~1~', a~2~', ... , a~ma~' for source S~A~, and similarly for other sources.

The output consists of plus, minus and zero set of values, denoted
op~1~, op~2~, ..., op~k~ for plus, om~1~, om~2~, ..., om~l~ for minus, and oz~1~, oz~2~, ..., oz~m~ for zero set.

So the above picture can be augmented with the values like this:

image::data-mapping.png["Data mapping"]

An example:

image::data-mapping-example.png["Data mapping example"]

NOTE: The question is why there is only one source object. In fact, with the advent of the concept of
link:https://wiki.evolveum.com/display/midPoint/Linked+objects[linked objects] one can imagine a mapping that would
operate on a set of all objects connected to the focus via particular link type: e.g. a mapping in a parent user could
obtain a list of his/her children's names simply by referencing `name` in `linkSource("child")` object set specification.
However, this is really far ahead of us.

If we use combinatorial evaluation (this is the case for most of the time) the values are constructed like this:

image::data-mapping-values.png["Data mapping (values)"]

i.e. output value o~j~ (or, sometimes, more values e.g. o~k~, o~l~, ...) are computed from values
a~ia~, b~ib~, ..., z~iz~ from sources S~A~, ..., S~Z~, respectively, taking a combination of i~a~, ..., i~z~-th
value from respective value sets of these sources. (It is also possible that the set of output values
for an input combination is empty.)

An example:

image::data-mapping-values-example.png["Data mapping (values, example)"]

=== Metadata mapping

Here we have to start thinking of metadata.

We need to compute metadata for each of the output values produced. For simplification, we can assume that
if a mapping produces more than one output value for a given combination of input values, all of them will
get the same metadata. Therefore, we can restrict our thinking to metadata for single output value.

From the metadata point of view it is not important if the (data) values are being added or kept unmodified by
the mapping. The only thing we look at is that we want to skip computing metadata for values that go
into the output minus set. footnote:[Even this is questionable. Consider e.g. assigned focus mappings
for an assignment that is being deleted. We have to review such a situation eventually.]

Metadata for given value are organized into _items_ just like ordinary data in objects are. Standard data
mappings reference their sources and target as items. It is natural for metadata mappings to do the same.
In this way we could have partial mappings for (e.g.) level of assurance item, confidentiality item,
creation time item, and so on. These mappings can be applied independently (and selectively, if needed),
just like ordinary mappings are applied to data objects.

There are some differences, though.

1. The first and perhaps more obvious difference is that while for standard data mapping we have exactly
one input object, for metadata mappings we have multiple input metadata collections. For each
input data value there is separate metadata. (Represented as a set of metadata items. Technically,
metadata is represented by prism container value.)

2. Second difference is that at the metadata level we have no deltas. An input value (kept unchanged
or being added) has its own metadata, and this metadata is immutable. It was attached to the value
when the value was created, and will never be changed. (As the value itself does not change.
It can be created or deleted, but never changed.) footnote:[What about container value e.g. assignment
modifications? Can we view that as value deletion and creation operations?] footnote:[Also interesting
is the following use case: _Have information about provisioning targets for data. Know where the data
are provisioned to or where they were provisioned in the past._ This would probably require modifications
of metadata in the opposite direction, i.e. going from outputs to source values.]

==== Metadata mapping model

So, we have a situation where we combine input values a, b, ..., z from sources S~A~, S~B~, ..., S~Z~ into
an output value. (For example, S~A~ = `givenName`, S~B~ = `familyName`, output = `fullName`).

A _metadata mapping_  has _sources_ and _output_ just like ordinary data mapping. However, sources do not reference
S~A~, S~B~, ..., S~Z~. They are orthogonal to data mapping sources. Metadata mapping sources reference
metadata items, like level of assurance, confidentiality, value origin, creation time, and so on.
Each source corresponds to a single _metadata item_, just like mapping source corresponds
to a single object item. Also, the output corresponds to a single metadata item; just like in mappings.

So, for example, our metadata mapping can have two sources: `loa` (level of assurance) and `source` (source system)
and one output `loa` (resulting level of assurance). The rule could be simple: take the lowest level of assurance
of all inputs. But if `source` is `socialLogin` then override the computation and use `loa` of `unknown`.
(This example is weird. But it is here to demonstrate metadata mapping with two sources.)
----
<metadataMapping>
    <source>
        <path>loa</path>
    </source>
    <source>
        <path>source</path>
    </source>
    <expression> ... </expression>
    <target>
        <path>loa</path>
    </target>
</metadataMapping>
----

Example evaluation:

image::metadata-mapping-values-example.png["Metadata mapping"]

(Again, normally single `familyName` value would not have two sources. But in this example it has.)

Looking at metadata evaluation only:

image::metadata-mapping-exemplified.png["Metadata mapping exemplified"]

And, if we slightly generalize this picture, we get the following:

image::metadata-mapping.png["Metadata mapping"]

Note that sources are marked S~A~, S~B~, ..., S~Z~, whereas metadata sources are orthogonal. For the lack
of invention let's mark them MS~&#945;~, MS~&#946;~, ..., MS~&#969;~. Input values for metadata transformation
are then given by the matrix (shown here as table):

[%header]
[cols="10,10,10,4,10"]
|===
| Data/metadata source          | Source A | Source B | ... | Source Z
| MS &#945; | A&#945;~1~, A&#945;~2~, ... | B&#945;~1~, B&#945;~2~, ...  | ... | Z&#945;~1~, Z&#945;~2~, ...
| MS &#946; | A&#946;~1~, A&#946;~2~, ... | B&#946;~1~, B&#946;~2~, ...  | ... | Z&#946;~1~, Z&#946;~2~, ...
| ... | ... | ... | ... | ...
| MS &#969; | A&#969;~1~, A&#969;~2~, ... | B&#969;~1~, B&#969;~2~, ...  | ... | Z&#969;~1~, Z&#969;~2~, ...
|
|===

TODO (continue...)