= MidScale: Prism Design

WARNING: This document is draft of preliminary notes for Prism Design meeting


.Guests:
* Radovan Semancik
* Katarina Bolemant
* Pavol Mederly
* Anton Tkacik
* Igor Farinic
* Kamil Jires
* Richard Richter



== Overview

The goal of _design meeting_ is to figure out design details about evolution of Prism in order to improve performance and scaling of Prism and MidPoint.

Design meeting is a creative, free-form discussion.
It may be following an agenda, but it is usually closer to a free-form brainstorming.

== Schedule

NOTE: Design meetings are schedules as needed, the schedule is not fixed.
For midPoint, the design meeting usually happens at the beginning of a development cycle or milestone cycle.

== What To Discuss

=== Motivation and Requirements

NOTE: What is the *motivation* to discuss this topic at all?
Do customers need it?
What are the *use cases*?
Will it help make deployments better/faster?
How exactly?

==== Motivation

Prism is present at every component of midPoint and provides basic infrastructure for data representation and manipulation. The performance, scalability and features of Prism directly affects scalability of midPoint as a whole.


==== Use cases

* Prism provides schema for data, which is used for data (un)marshalling, data  processing and validaiton

* Prism provides data marshalling / unmarshalling capabilities based on schema

* Prism serves as primary in-memory data structures for representing processed   data

* Prism provides basic primitives for data processing and trasnformation such as data modification, data equivalency

* Prism as base for client and midPoint


NOTE: What are the *assumptions*?
What we expect that customers will do?
Maybe we are not certain about some requirements and we just assume something?

==== Assumptions

 * For foreseable future Prism is in midPoint context
 * Axiom based schema

// * Focus is to make it work in our private cloud. No effort shall be spend on the abstractions and preparation on the other clouds.

//* system components: mP, LDAP, PSQL, other resource prefer DBTables (PSQL) not files (scalability).

//* We will focus on docker and dockerization, not hybrids for now (VM/Windows).


==== Ideal State



==== Requirements

* Profiling - open question for now


===== Testing Environment Requirements

* 1-2 source systems
  ** PostgreSQL
* 10k-100k records
* 4x targets systems
  ** 2x OpenLDAP
  ** 2x Database
* Large extension schema (counts by Katarina)
* Archetypes 3x
* Assigments per user: 10-100 (average 40)
  - 20% expired
  - conditions in aassigments
- 2 midPoint node: 16GB RAM
- DB server: 16GB RAM



==== Performance and scalability goals

NOTE: Do we have some *performance* or *scalability* targets?
Do we know how big a system do we want to support?
How many users, how many requests per second, special usage patterns (bursts), anything else?

//* Start with 1mio of records, target 10+ mio, in order of magnitude tens of milions

//* The records are like carthesian product: 10 mio of users, each 10 accounts is like 100 milions of shadows

//* Open question: number of other objects? Like roles, services, orgs? And also many assignments slow down problem





=== Ideas and Concepts


[NOTE]
====
When thinking about the use cases, do not limit your thoughts to just that one specific use case.
Think about generic mechanisms, broader principles.
Focus on *concepts* and ideas, rather than algorithms.
Design mechanism that can handle your use case, and thousands of similar use cases as well.
Design *generic re-usable mechanisms*.

Make sure the new mechanisms work well with existing mechanisms.
We are looking for *synergies*.
We want to combine mechanisms together into more flexible and more powerful solutions.
====



==== Thread Safety

* Thread safety
  - Thread safety issues & immutability
    - Pure JAXB beans - immutable, replace Gregorian Calendar, ordered lists
    - XNodes with DOM (locking on DOM document)
    - OperationResult
    - ReadOnly flag for clients (default)
    - Schema

==== Performance

* Big Items
//** Container with lot of items -  Problem of many attributes for an object (100+).
** Item with lot of values
*** Duplication checks -HashSet??? - requires Immutability of nested values
* Application of Authorization & Schema
** Smart schema builders
*** change label
*** change flags
          - removal of items
       - Object caching

    * Parsing & Serialization


==== Memory

* Application of Authorization & Schema
   - Smart schema builders
      - change label
      - change flags
      - removal of items
   - Object caching

* Parsing & Serialization



=== Implementation

TODO: feasibility

=== Performance and Scalability Considerations

TODO

=== Testability Considerations

Make sure that the functionality can be tested.
Think about the testing process.
Can this be teste by the ususal mechanisms that we have?
Will we need some special environment or setup?


=== Security Considerations

TODO

=== Rolling Wave Design

TODO

== Write It Down

Notes from design meeting at the appropriate place.
For midPoint, the appropriate place is usually https://docs.evolveum.com/midpoint/devel/design/[Design Notes at docs] for public notes, or https://guide.priv.evolveum.com/midpoint/notes/[MidPoint Design Notes at guide] for private notes.

Do not forget to document:

* *Requirements* and *assumptions*. Interesting *use cases*.

* Outline of the *approach*, important aspects of algorithms, schemas and so on.

* *Decisions* that were made, also the explanation or *motivation* _why_ the decision was made.

* Outline of a *plan*.
What do we implement now?
What parts will remain to be implemented later?

* *Risks* and challenges.
What parts are likely to be problematic?
Where can the design fail?

* *Open questions*.
What we cannot answer now?
What problems remain to be solved later?
