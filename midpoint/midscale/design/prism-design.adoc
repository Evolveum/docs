= MidScale: Prism Design

WARNING: This document is draft of preliminary notes for Prism Design meeting


.Guests:
* Prism Developers

* Prism Users



== Overview

The goal of _design meeting_ is to figure out design details about evolution of Prism in order to improve performance and scaling of Prism and MidPoint.

Design meeting is a creative, free-form discussion.
It may be following an agenda, but it is usually closer to a free-form brainstorming.

== Schedule

NOTE: Design meetings are schedules as needed, the schedule is not fixed.
For midPoint, the design meeting usually happens at the beginning of a development cycle or milestone cycle.

== What To Discuss

=== Motivation and Requirements

NOTE: What is the *motivation* to discuss this topic at all?
Do customers need it?
What are the *use cases*?
Will it help make deployments better/faster?
How exactly?

==== Motivation

Prism is present at every component of midPoint and provides basic infrastructure for data representation and manipulation. The performance, scalability and features of Prism directly affects scalability of midPoint as a whole.


==== Use cases

* Prism provides schema for data, which is used for data (un)marshalling, data  processing and validaiton

* Prism provides data marshalling / unmarshalling capabilities based on schema

* Prism serves as primary in-memory data structures for representing processed   data

* Prism provides basic primitives for data processing and trasnformation such as data modification, data equivalency

NOTE: What are the *assumptions*?
What we expect that customers will do?
Maybe we are not certain about some requirements and we just assume something?

==== Assumptions

// * Focus is to make it work in our private cloud. No effort shall be spend on the abstractions and preparation on the other clouds.

//* system components: mP, LDAP, PSQL, other resource prefer DBTables (PSQL) not files (scalability).

//* We will focus on docker and dockerization, not hybrids for now (VM/Windows).


==== Requirements

* Profiling - open question for now





==== Performance and scalability goals

NOTE: Do we have some *performance* or *scalability* targets?
Do we know how big a system do we want to support?
How many users, how many requests per second, special usage patterns (bursts), anything else?

//* Start with 1mio of records, target 10+ mio, in order of magnitude tens of milions

//* The records are like carthesian product: 10 mio of users, each 10 accounts is like 100 milions of shadows

//* Open question: number of other objects? Like roles, services, orgs? And also many assignments slow down problem

* Problem of many attributes for an object (100+).



=== Ideas and Concepts


[NOTE]
====
When thinking about the use cases, do not limit your thoughts to just that one specific use case.
Think about generic mechanisms, broader principles.
Focus on *concepts* and ideas, rather than algorithms.
Design mechanism that can handle your use case, and thousands of similar use cases as well.
Design *generic re-usable mechanisms*.

Make sure the new mechanisms work well with existing mechanisms.
We are looking for *synergies*.
We want to combine mechanisms together into more flexible and more powerful solutions.
====

=== Implementation

TODO: feasibility

=== Performance and Scalability Considerations

TODO

=== Testability Considerations

Make sure that the functionality can be tested.
Think about the testing process.
Can this be teste by the ususal mechanisms that we have?
Will we need some special environment or setup?

=== Security Considerations

TODO

=== Rolling Wave Design

TODO

== Write It Down

Notes from design meeting at the appropriate place.
For midPoint, the appropriate place is usually https://docs.evolveum.com/midpoint/devel/design/[Design Notes at docs] for public notes, or https://guide.priv.evolveum.com/midpoint/notes/[MidPoint Design Notes at guide] for private notes.

Do not forget to document:

* *Requirements* and *assumptions*. Interesting *use cases*.

* Outline of the *approach*, important aspects of algorithms, schemas and so on.

* *Decisions* that were made, also the explanation or *motivation* _why_ the decision was made.

* Outline of a *plan*.
What do we implement now?
What parts will remain to be implemented later?

* *Risks* and challenges.
What parts are likely to be problematic?
Where can the design fail?

* *Open questions*.
What we cannot answer now?
What problems remain to be solved later?














== Topics
* Separation of schema & data & logic?
** Prism Data Structures contains reference to schema / description
*** If data needs to be interpreted according to different schema,
    we need to modify them / clone them.
**** Repository vs Provisioning - provisioning changes schema for some data - data needs to be cloned / replaced
**** ACLs as schema - data needs to be modified / items removed in order to provide subview

=== Performance

=== Memory



Improvement to Prism, fundamental data representation layer of midPoint.

* Thread safety
  - Thread safety issues & immutability

* Identification of performance issues (bottleneckes): profiling




* Immutability concepts (for stability)


* Axiom next steps (only the necessary steps)







 * Model "compilation"
  ** Current form of definition structures is not optimized for some of the lookups
  *** supertype hierarchy (supertype is referenced only by name)


=== Thread Safety



=== Immutability

Prism in version 4.1 introduced Freezable concept - objects can be frozen
and can not change after freeze.



=== Freezable Pattern vs Buildable Pattern

|===
| Issue  | Freezable | Buildable

| **Description**

| Objects can be frozen to prevent further modifications
| Objects are not mutable by design

| **Construction**
| Instance used for construction is same as final product
| Separate construction object, final product is new instance

| **Multi-threading / Sharing between components**
| Instance need to be frozen or cloned to share between thread
| Safe sharing of objects

| **API**
| No API visible separation between mutable and immutable version, needs
  to be documented in text
| Clear separation between mutable and immutable version

| **Modification**
| Not frozen object can be modified directly, frozen (shared)
  object needs to be cloned in order to modify.
| **Copy-on-Write:** Object needs to be cloned in order to modify (can reuse children if they are unmodified).


| **Verbosity**
| Less verbose use & construction
| More verbose construction


|===

=== Prism Schema

=== Prism Data Structures




== Cloning
