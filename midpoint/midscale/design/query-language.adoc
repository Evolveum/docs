= Query Language Design Notes
:page-nav-title: Query Language

NOTE: All examples are only for discussion and does not represent any current
functionality


== Terminology

Filter:: A set of conditions / predicates used to select subset of data

Query:: Combination of filter and transformation / ranking / ordering
specification to retrieve set of data

== Design

NOTE: Primary design should be put into filter part, with most common use-cases
being less verbose


[cols="a,a,a,a"]
|===
| XML | 1:1 Axiom | Axiom with Argument | Axiom, type as equals special case, top clause is always AND
|

----
<filter>
  <type>
    <type>UserType</type>
    <filter>
      <ref>
        <path>
          assignment/orgRef
        </path>
        <value oid="OID" />
      </ref>
    </filter>
  </type>
</type>
----
|

----
filter {
  type {
    type UserType;
    filter {
      ref {
        path assignment/orgRef;
        value "OID";
      }
    }
  }
}
----

|
----
filter {
  type {
    type UserType;
    filter {
      ref assignment/orgRef {
        value "OID";
      }
    }
  }
}
----
|
----
filter {
  type UserType;
  ref assignment/orgRef {
    value "OID";
  }
}
----

.XPath like
----
@type=UserType && assignment/orgRef="OID"
----

.JIRA /SQL like
----
type = UserType AND assignment/orgRef = "OID"
----


.Google like
----
type:UserType assignment/orgRef:OID
----

|
|===






.Value Filters
|===
| Existing | Right Side | Modifiers | Proposed Name | True State

.3+| Equals
| Value .3+| matchingStrategy | Equals |Any value of left property matches value on right
| Multiple Values, Path | In | Any value of left property matches any value on right
| Null | IsEmpty | Property does not have value


| Comparison  | Value | matchingStrategy | Comparison | Any value of property is smaller / larger / equals then right value.


.4+| Substring .4+| Value, Property

| matchingStrategy, anchorLeft=false, anchorRight=false | Substring | Any value of property contains any substring from right
| matchingStrategy, anchorLeft=true, anchorRight=false | StartsWith | Any value of property starts with any substring from right
| matchingStrategy, anchorLeft=false, anchorRight=true | EndsWith | Any value of property ends with any substring from right
| matchingStrategy, anchorLeft=true, anchorRight=true | Equals? | Any value of property equals to any string from right

| Ref filter | Value, Property | oidNullAsAny, targetTypeAsAny, relationTypeAsAny | References? Matches? | Any value of reference matches any value from right side




| Org filter |

.2+| InOid filter .2+| Value, Property |

|===



== Notes & Scribles

Existing state:

Namespaces?

axiom?
----
or {
  substring {
    path c:employeeType;
    value A;
  }
  substring {
    path c:employeeType;
    value B
    anchorStart true;
  }
}


exists assignment { // arg is path
  filter {
    ref tenantRef { // arg is path
      value oid1; // value
    }
    ref orgRef { // arg is path
      value oid2; // arg is oid
    }
  }
}
----


[cols="a,a,a"]
|===
|
----
<or>
    <and>
        <greater>
            <path>c:costCenter</path>
            <value>100000</value>
        </greater>
        <less>
            <path>c:costCenter</path>
            <value>999999</value>
        </less>
    </and>
    <and>
        <greaterOrEqual>
            <path>c:costCenter</path>
            <value>X100</value>
        </greaterOrEqual>
        <lessOrEqual>
            <path>c:costCenter</path>
            <value>X999</value>
        </lessOrEqual>
    </and>
</or>
----
|
----
or {
  and {
    greater c:costCenter {
      value 100000;
    }
    less c:costCenter {
      value 999999;
    }
  }
  and {
    greaterOrEqual c:costCenter {
      value X100;
    }
    lessOfEqual c:costCenter {
      value X999;
    }
  }
}
----
|
----
or {
  valueOf c:costCenter {
    and {
      greater 100000;
      less 999999;
    }
  }
  valueOf c:costConter {
    and {
      greaterOrEquals X100;
      lessOrEquals X999;
    }
  }
----

----
valueOf c:costCenter { // Select(c:costCenter)
  or {
    and {
      greater 100000;
      less    999999;
    }
    and {
      greaterOrEquals X100;
      lessOrEquals X999;
    }
  }
}
----
|===

----

c:costCenter:: (>100000 and <999999 ) | (>= X100 and <= X999)


Predicate and(Predicate...);
Predicate or(Predicate...);

Selector


Predicate
Selector
----

type ValuePredicate {
  // Value enumerations
  item anyOf; // Effectivelly OR
  item allOf; // Effectivelly AND
  item equals;


  // All subitems are and
  item smallerThan;
  item largerThan;



  // String predicates
  item startsWith;
  item endsWith;
  item contains;
}


valueOf c:costCenter {

}










|===
|Condition | Arguments | Description

|all | | All items
|none | | None
|undefined | | Undefined, NOOP filter

3+| *Value comparison*

|equal | path, ValueSpec |
|greater | path, ValueSpec |
|greaterOrEqual | path, ValueSpec |
|less | path, ValueSpec |
|lessOrEqual | path, ValueSpec |
|substring | path, ValueSpec |

3+| *Special*
|ref | path, ValueSpec<ObjectReference> |
|org | |
|inOid | Oid | Currently special case of 'equal' filter
|fullText | |
|present | |
|true | |
|and | Predicate... |
|or | Predicate... |
|not | Predicate... |
|type | Type, Filter | Accepts if the object is of type T and filter F passes.
|exists | Path, Filter | Accepts iff there exists a value v of item I so that F(v) passes. This is useful e.g. to find an assignment with a given tenantRef and orgRef.
|===



----
Search: FilterClause
FilterClause: All | None | Undefined | LogicOperation | ValueComparison | Ref | Org | Type | Exists
LogicOperation: And | Or | None
And: "AND" FilterClause+
Or: "OR" FilterClause+;
Not: "NOT" FilterClause;
ValueComparison: Operation Path ValueSpec+;
ValueSpec: Path | Value;
Ref: ...
Org: ...
Type: TypeSpec FilterClause
Exists:
----

== Discussion 2020-10-28

* Assignment as (almost) first-class object?
Or make it possible to query any container?


* Ad-hoc joins (joins that do not follow prism reference): do we need them?
Do not support them, at least for now.
But this may change in the future.

** We would need aliases for objects in order to distuinguish path

----
// Not linked shadows
FROM ShadowType AS s
LEFT JOIN UserType AS u ON s/oid = u/linkRef
FILTER u NOT EXISTS
----


* Syntax for "reference match", "polystring match" and similar.


* Are matching rules for polystring a good idea?
Maybe we need patterns instead of matching rules.


* Should matching rules be in fact _string_ matching rules?
Do we need other cases, e.g. matching of IP address and netmask?
** Tony: Similar special case is _DistuinguishName_, this feels more like
   separate value types for DN, IP Address with their own matching rules
   (eg. in DB serialized like `dn_orig` and `dn_norm`, where `dn_norm` is used for filters).


* Make sure that NOT queries are supported.
E.g. "find users that do not have any linked account".

.Some Examples
----
TYPE UserType AND linkRef IsEmpty
TYPE UserType AND linkRef NOT EXISTS

// Users which do not have manager relationship
TYPE UserType AND assigment/targetRef NOT MATCHES (relationship="manager")

TYPE UserType AND assigment/targetRef/relationship != "manager"

assigment MATCHES (construction=order AND )


SELECT * FROM FocusType
WHERE /assigment MATCHES (construction=a AND order = b)

WHERE /assigment MATCHES ( targetRef EXISTS)

SELECT * FROM FocusType
WHERE /assigment MATCHES (construction=a AND order = b)


FIND FocusType/assigment WHERE construction=a AND order=b
FIND UserType/assigment WHERE construction=a AND order=b

FIND UserType WHERE /assignment MATCHES EMPTY // contains empty assignment
FIND UserType WHERE /assignment NOT EXISTS // does not exits
FIND UserType WHERE /assignment EXISTS // has any value
FIND UserType WHERE /assignment MATCHES () // has any value
FIND UserType WHERE /assignment NOT EXISTS AND /assignment/@assurance > HIGH
----

.Existence filters for containers
[cols=",,a"]
|===
| Filter | Usage | Description

| MATCHES
| path MATCHES ( filter )
| True if any value of path matches specified nested filter. Filter evaluation
  root is value.

| MATCHES EMPTY
| path MATCHES EMPTY
| Special case, returns true if path contains value, which is 'empty' - does not
  contain any containers, properties

| EXISTS
| path EXISTS
| True if path contains any value (even empty). This is same as `path MATCHES ()`

|NOT EXISTS
| path NOT EXISTS
| True if path does not contain any values or does not exist. Path may physically exists, because of metadata,
  but without values.

[source]
----
/assignment NOT EXISTS AND /assignment/@assurance > 4`.
----
This is true, if path container /assigment does not contain any values, but item metadata
for /assigment are present and @assurance is higher than 4.

|===


* How to do "group by" queries?
** Does group by creates ad-hoc schema?

Discussed solution was to provide 2 concepts:
 * Simple "dashboard"-like model which allows to specify item paths to fetch,
    and apply aggregate operations on these paths (grouping, min, avg, count)
    and filter (this model does not allows for complex grouping / queries - easier to map to database)
 * Experimental dashboard - Custom schema + query which retrieves data


----
SELECT s/resouceRef, count(s) AS count FROM ShadowType AS s
LEFT JOIN UserType AS u ON s/oid = u/linkRef
FILTER u NOT EXISTS
GROUP BY s/resourceRef
----

.Report Syntax proposal
----
statusReport {
  from ShadowType;

  collumn name {
    displayName "Resource";
    source resourceRef/@/name {
      type grouping;
    }
  }
  collumn kind {
    source kind {
      type grouping;
    }
  }
  collumn intent {
    source intent {
      type grouping;
    }
  }
  collumn status {
    source status {
      type grouping;
    }
  }
  collumn count {
    displayName "Count";
    source  {
      count;
    }
  }

}
----


----

statusReport {
  from UserType;
  collumn directorate {
    displayName "Name";
    source extension/directorateRef/@/name {
      grouping;
    }
  }
  collumn count {
    source {
      count;
    }
  }
  filter """
    activation/efectiveStatus = disabled
  """;

}



----


.Sample SQL query used for custom overview
----
select

    count(*) AS (prism definiciu),
    r.name_orig,
    s.kind,
    s.intent,
    case s.SYNCHRONIZATIONSITUATION
        when 0 then 'DELETED'
        when 1 then 'UNMATCHED'
        when 2 then 'DISPUTED'
        when 3 then 'LINKED'
        when 4 then 'UNLINKED'
        end as SITUATION,
    s.resourceref_targetoid
from m_shadow s
left join m_resource r on s.resourceref_targetoid=r.oid
group by
    r.name_orig,
    s.kind,
    s.intent,
    s.SYNCHRONIZATIONSITUATION,
    s.resourceref_t
----
