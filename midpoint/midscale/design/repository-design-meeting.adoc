= Repository Design Meeting

== Meeting notes 2020-10-20

* Capacity
** Goal to support up to 20M around end of 2021 (e.g. now 8M, growing around 300K monthly).

* Is PostgreSQL enough from business perspective? What about Oracle?
** If it's optimized for PG, tests must be run against PG as well, H2 will not cover new repo at all.
** Primary goal is PG, but let's not close the door for Oracle too soon.

* Current DB schema problems:
** `M_OBJECT` is too heavy (full object?)
** `M_SHADOW` table is too big (10-20 times `M_USER` size), talk 200M expected soon.
Indexes are not enough, little variance in data (resource, object class, kind, intent).
TODO: Can this be split/partitioned by resource and/or object class?
Is there application-transparent (fully DB-managed) solution or do we need to manage table hierarchy as we go?
Let's try partitions first and test the performance.
Check limitations about contstraints for partitioned tables.
** `M_REFERENCE` can be too big (goal >100M), can be split by `REFERENCE_TYPE` which is always used for query.
TODO: Check PostgreSQL https://www.postgresql.org/docs/9.1/ddl-inherit.html[table hierarchy].

* Scalability, table hierarchy, relations:
** Separate oid/type table for all objects (quick searches by oid)?
Yes, can be handy.
Alternatives: view, materialized view (refresh?).
** `full_object` LOB in concrete tables? all-object table (like now)? separate full-object table?
On concrete classes (leaf tables), current solution causes heavy contention on `M_OBJECT`.
Also, this will make the `M_OBJECT` smaller by volume and full-table-scan reads less data.
** What about search for supertype (like any focus with some attribute equals to...)?
Examples: Searching all members of a role (assignment holder).
Unsure how critical the performance is, optimizations possible for specific queries.
It seems table inheritance would be a solution here (this may close the door https://stackoverflow.com/questions/17512871/how-to-create-inherited-table-in-oracle[for Oracle]).
** But what about associations, e.g. assignments?
We don't want to model them n-times for various types (we already don't).
Can they reference all-objects table for referential integrity?
Only owner side (currently `OWNER_OID`), but it's not possible to enforce FK to target (`TARGETREF_TARGETOID`).
Owner can have reference/assignment to non-existing target.

* What about task repository/manager?
** No changes expected at this moment.
Replacing core repository should not have impact on `task-quartz-impl` module.
** But improvements in bucket selection are welcome, there is big contention.

* How to get to minimum viable product (MVP) as soon as possible?
** In 4.3 we'd like to have rough implementation of `repo-api` (`RepositoryService`).
** In 1-2 months to have representative DB schema covering most issues mentioned above.
Testing on SQL level with many rows, etc.

TODO:

* extension, table vs column, collections
** Will we just create new custom columns or new tables as well?
** can indexable JSON cover this?
** What about management? Can we allow MP to alter tables?
If not what will create the columns conveniently yet safely (no typos, indexes when necessary)?

* audit considerations? what is missing now? what about audit archiving (unsearchable?)
** Time partitions?

* module design, currently audit is implemented in repo-sql-impl
** don't we want `audit-impl` use only some `repo-...` (common? but not our "common = all")
** what about `repo-cache`, do we need (or want) to change it?

* what else?

== Current schema to repository mapping

|===
| Schema type | Repo type | Note

3+| *Objects*
| ObjectType .2+| RObject |
| \|- AssignmentHolderType |
| \|{nbsp}\|-{nbsp}AbstractAccessCertificationDefinitionType | - |
| \|{nbsp}\|{nbsp}\|-{nbsp}AccessCertificationDefinitionForReportType | ? |
| \|{nbsp}\|{nbsp}+-{nbsp}AccessCertificationDefinitionType | RAccessCertificationDefinition |
| \|{nbsp}\|-{nbsp}AccessCertificationCampaignType | RAccessCertificationCampaign |
| \|{nbsp}\|-{nbsp}CaseType | RCase |
| \|{nbsp}\|-{nbsp}ConnectorHostType | RConnector |
| \|{nbsp}\|-{nbsp}ConnectorType | RConnectorHost |
| \|{nbsp}\|-{nbsp}DashboardType | RDashboard |
| \|{nbsp}\|-{nbsp}FocusType | RFocus |
| \|{nbsp}\|{nbsp}\|-{nbsp}AbstractRoleType | RAbstractRole |
| \|{nbsp}\|{nbsp}\|{nbsp}\|-{nbsp}ArchetypeType | RArchetype |
| \|{nbsp}\|{nbsp}\|{nbsp}\|-{nbsp}OrgType | ROrg |
| \|{nbsp}\|{nbsp}\|{nbsp}\|-{nbsp}RoleType | RRole |
| \|{nbsp}\|{nbsp}\|{nbsp}+-{nbsp}ServiceType | RService |
| \|{nbsp}\|{nbsp}\|-{nbsp}GenericObjectType | RGenericObject |
| \|{nbsp}\|{nbsp}+-{nbsp}UserType | RUser |
| \|{nbsp}\|-{nbsp}FormType | RForm |
| \|{nbsp}\|-{nbsp}FunctionLibraryType | RFunctionLibrary |
| \|{nbsp}\|-{nbsp}LookupTableType | RLookupTable |
| \|{nbsp}\|-{nbsp}NodeType | RNode |
| \|{nbsp}\|-{nbsp}ObjectCollectionType | RObjectCollection |
| \|{nbsp}\|-{nbsp}ObjectTemplateType | RObjectTemplate |
| \|{nbsp}\|-{nbsp}ReportDataType | RReport |
| \|{nbsp}\|-{nbsp}ReportType | RReportData |
| \|{nbsp}\|-{nbsp}ResourceType | RResource |
| \|{nbsp}\|-{nbsp}SecurityPolicyType | RSecurityPolicy |
| \|{nbsp}\|-{nbsp}SequenceType | RSequence |
| \|{nbsp}\|-{nbsp}SystemConfigurationType | RSystemConfiguration |
| \|{nbsp}\|-{nbsp}TaskType | RTask |
| \|{nbsp}+-{nbsp}ValuePolicyType | RValuePolicy |
| +-{nbsp}ShadowType | RShadow |
|===
