= Repository Design

* Capacity
** Goal to support up to 20M around end of 2021 (e.g. now 8M, growing around 300K monthly).

* Is PostgreSQL enough from business perspective? What about Oracle?
** If it's optimized for PG, tests must be run against PG as well, H2 will not cover new repo at all.
** Primary goal is PG, but let's not close the door for Oracle too soon.

* Current DB schema problems:
** `M_OBJECT` is too heavy (full object?)
** `M_SHADOW` table is too big (10-20 times `M_USER` size), talk 200M expected soon.
Indexes are not enough, little variance in data (resource, object class, kind, intent).
TODO: Can this be split/partitioned by resource and/or object class?
Is there application-transparent (fully DB-managed) solution or do we need to manage table hierarchy as we go?
Let's try partitions first and test the performance.
Check limitations about contstraints for partitioned tables.
** `M_REFERENCE` can be too big (goal >100M), can be split by `REFERENCE_TYPE` which is always used for query.
TODO: Check PostgreSQL https://www.postgresql.org/docs/9.1/ddl-inherit.html[table hierarchy].

* Scalability, table hierarchy, relations:
** Separate oid/type table for all objects (quick searches by oid)?
Yes, can be handy.
Alternatives: view, materialized view (refresh?).
** `full_object` LOB in concrete tables? all-object table (like now)? separate full-object table?
On concrete classes (leaf tables), current solution causes heavy contention on `M_OBJECT`.
Also, this will make the `M_OBJECT` smaller by volume and full-table-scan reads less data.
** What about search for supertype (like any focus with some attribute equals to...)?
Examples: Searching all members of a role (assignment holder).
Unsure how critical the performance is, optimizations possible for specific queries.
It seems table inheritance would be a solution here (this may close the door https://stackoverflow.com/questions/17512871/how-to-create-inherited-table-in-oracle[for Oracle]).
** But what about associations, e.g. assignments?
We don't want to model them n-times for various types (we already don't).
Can they reference all-objects table for referential integrity?
Only owner side (currently `OWNER_OID`), but it's not possible to enforce FK to target (`TARGETREF_TARGETOID`).
Owner can have reference/assignment to non-existing target.

* What about task repository/manager?
** No changes expected at this moment.
Replacing core repository should not have impact on `task-quartz-impl` module.
** But improvements in bucket selection are welcome, there is big contention.

* How to get to minimum viable product (MVP) as soon as possible?
** In 4.3 we'd like to have rough implementation of `repo-api` (`RepositoryService`).
** In 1-2 months to have representative DB schema covering most issues mentioned above.
Testing on SQL level with many rows, etc.

* Extensions:
** Currently both single- and multi-values stored in tables (per data type), multi-values as multiple lines.
*** There are separate sets of tables for "object extensions" and "assignment extensions".
** Possible solution:
*** Single valued extensions directly in the owning table.
*** Multi values in separate tables created on demand for each extension attribute.
Can indexable JSON array be solution?
** Shadow is a bit different, there are various attributes depending on resource schema.
Normally we don't cache attributes, in that case there is no problem, but what if we want to?
There are still identifiers, primary is in `M_SHADOW`, we don't have secondary/tertiary.
Problem also https://wiki.evolveum.com/display/midPoint/Identifier+Theory[described here].
** https://wiki.evolveum.com/display/midPoint/Advanced+Hybrid+RBAC[Parametric roles]
can/will contain definition of extended attributes, how to apply these to DB schema?
*** Assignment parameters are more like "shadow attributes" while schema extensions are global.
** Ability to apply necessary DB schema changes without the restart would be nice,
but reportedly not critical depending on the needed development effort.
*** DB part of this is perhaps easier than the refresh of Prism schemas...?
*** How to distribute new column information (or any change) across the cluster?
If DB has a new column and runtime mapping doesn't, what happens? Or the other way around.

* Uniqueness - of names but also other attributes, often depending on other attributes.
** E.g. user name is normally unique, but we may need to change it to name+tenantId (deployment specific).
** Should midPoint self-managed indexes and constraints (perhaps in 5.0 or later)?
** What before that? Separate part of schema that can be customized (various options, some commented)?

* Partial queries of objects without `FULL_OBJECT`, no LOB, no parsing:
** E.g. for some UI views or REST "return users only with names and..." (other data from columns).
See `GetOperationOptions` and `RetrieveOption` for existing mechanism.
** How to map it into schema types?
How to indicate the object is not complete?
** Performance of `getObject` must not get worse.

* Asynchronous audit - optional, per node, no cluster-wide microservice.
** Point of audit should be still able to work like today (synchronous audit).
** Additionally, if async-audit is on it queues the audit event.
** Consumer batches the inserts.
** What if audit query is executed? Should it trigger the flush operation first?

TODO:

* Extensions contd.
** Audit custom properties? How is this different from extension columns (schema-wise and DB-wise)?
** can indexable JSON cover this? later research

* DB schema management capabilities.
** What if MP will not be allowed to alter tables?
If not what will create the columns conveniently yet safely (no typos, indexes when necessary)?
** Objects to manage:
*** Custom indexes - for extension columns.
*** Custom constraints - uniqueness customizations.
*** Custom tables - for to-many extensions, unless JSON can solve this.
Dynamic table creation can be also needed for shadow extensions (per resource).
Possibly, this can also be used for assignments (per dynamic role?) or other objects
(archetypes with dynamic schema extensions).

* audit considerations? what is missing now? what about audit archiving (unsearchable?)
** Time partitions?

* module design, currently audit is implemented in repo-sql-impl
** don't we want `audit-impl` use only some `repo-...` (common? but not our "common = all")
** what about `repo-cache`, do we need (or want) to change it?

== Current schema to repository mapping

|===
| Schema type | Repo type | Note

3+| *Objects*
| ObjectType .2+| RObject |
| \|- AssignmentHolderType |
| \|{nbsp}\|-{nbsp}AbstractAccessCertificationDefinitionType | - |
| \|{nbsp}\|{nbsp}\|-{nbsp}AccessCertificationDefinitionForReportType | ? |
| \|{nbsp}\|{nbsp}+-{nbsp}AccessCertificationDefinitionType | RAccessCertificationDefinition |
| \|{nbsp}\|-{nbsp}AccessCertificationCampaignType | RAccessCertificationCampaign |
| \|{nbsp}\|-{nbsp}CaseType | RCase |
| \|{nbsp}\|-{nbsp}ConnectorHostType | RConnector |
| \|{nbsp}\|-{nbsp}ConnectorType | RConnectorHost |
| \|{nbsp}\|-{nbsp}DashboardType | RDashboard |
| \|{nbsp}\|-{nbsp}FocusType | RFocus |
| \|{nbsp}\|{nbsp}\|-{nbsp}AbstractRoleType | RAbstractRole |
| \|{nbsp}\|{nbsp}\|{nbsp}\|-{nbsp}ArchetypeType | RArchetype |
| \|{nbsp}\|{nbsp}\|{nbsp}\|-{nbsp}OrgType | ROrg |
| \|{nbsp}\|{nbsp}\|{nbsp}\|-{nbsp}RoleType | RRole |
| \|{nbsp}\|{nbsp}\|{nbsp}+-{nbsp}ServiceType | RService |
| \|{nbsp}\|{nbsp}\|-{nbsp}GenericObjectType | RGenericObject |
| \|{nbsp}\|{nbsp}+-{nbsp}UserType | RUser |
| \|{nbsp}\|-{nbsp}FormType | RForm |
| \|{nbsp}\|-{nbsp}FunctionLibraryType | RFunctionLibrary |
| \|{nbsp}\|-{nbsp}LookupTableType | RLookupTable |
| \|{nbsp}\|-{nbsp}NodeType | RNode |
| \|{nbsp}\|-{nbsp}ObjectCollectionType | RObjectCollection |
| \|{nbsp}\|-{nbsp}ObjectTemplateType | RObjectTemplate |
| \|{nbsp}\|-{nbsp}ReportDataType | RReport |
| \|{nbsp}\|-{nbsp}ReportType | RReportData |
| \|{nbsp}\|-{nbsp}ResourceType | RResource |
| \|{nbsp}\|-{nbsp}SecurityPolicyType | RSecurityPolicy |
| \|{nbsp}\|-{nbsp}SequenceType | RSequence |
| \|{nbsp}\|-{nbsp}SystemConfigurationType | RSystemConfiguration |
| \|{nbsp}\|-{nbsp}TaskType | RTask |
| \|{nbsp}+-{nbsp}ValuePolicyType | RValuePolicy |
| +-{nbsp}ShadowType | RShadow |
|===
