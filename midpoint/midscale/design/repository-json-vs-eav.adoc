= Comparing JSONB and EAV model for extensions

[NOTE]
Performance was measured on default PG installation on 2GB RAM VirtualBox with 1 vCPU.
The results can be better (or worse depending on the host) but not order-of-magnitude different.

See link:sql/pgnew-eav-vs-json.sql[] for the whole source.

Structure for JSON is simple, single table `tjson` with `(oid UUID PK, name VARCHAR, ext JSONB)`.
Column `name` has a unique index and `ext` has a `GIN` index only by default.
Other indexes are added as needed and mentioned during tests.

Structure for EAV model has a master table `teav` with `(oid UUID PK, name VARCHAR)`
with unique index on the `name`.
Detail table `teav_ext_string` contains `(owner_oid FK, key VARCHAR, value VARCHAR)`.
Extension table has `PK(owner_oid, key, value)`, that is all columns, value could be omitted if uniqueness is not necessary.
Because the PK covers all columns, it should be index-organized table in Oracle (PG doesn't have this feature).
In PG it can be https://www.postgresql.org/docs/13/sql-cluster.html[clustered] by an index,
but this is potentially costly (12min for 15M rows) during which the table is unusable
because of the used `ACCESS EXCLUSIVE` lock.

Utility `pgbench` can be used for measurements like so:

----
pgbench -r -P 5 -f /vagrant/tmp/jsonb-eav-test.sql
----

Results can be taken from the final report of average latency per statement (enabled by `-r` option).
Results may vary widely between runs, especially for shorter queries.
Also, running the whole script and running smaller bulks provides different results as well,
typically better for smaller amount of statement (this may be caused by rather limited VM performance).
Measurements for shorter queries were repeated with longer queries commented out and option `-t 30`
to get more repetitions per statement (30 in this case) which typically leads to lower, but also more representative, averages.

== Insert

Insert loop is created in such a way that both version have exactly the same data, even where randomized.

[source,sql]
----
-- start with smaller batches 1..1000, 1001..100000, etc.
DO
$$
DECLARE
    hobbies VARCHAR[];
    v VARCHAR;
    id UUID;
BEGIN
    FOR r IN 11000001..15000000 LOOP

        IF r % 10 <= 1 THEN
            -- some entries have no extension
            INSERT INTO tjson (name) VALUES ('user-' || LPAD(r::text, 10, '0'));
            INSERT INTO teav (name) VALUES ('user-' || LPAD(r::text, 10, '0'));
        ELSEIF r % 10 <= 3 THEN
            -- email+eid (constant keys) + other-key-{r} (variable key)
            INSERT INTO tjson (name, ext) VALUES (
                'user-' || LPAD(r::text, 10, '0'),
                ('{"eid": ' || r || ', "email": "user' || r || '@mycompany.com", "other-key-' || r || '": "other-value-' || r || '"}')::jsonb
            );
            INSERT INTO teav (name) VALUES ('user-' || LPAD(r::text, 10, '0')) RETURNING oid INTO id;
            INSERT INTO teav_ext_string (owner_oid, key, value) VALUES (id, 'email', 'user' || r || '@mycompany.com');
            INSERT INTO teav_ext_string (owner_oid, key, value) VALUES (id, 'eid', r);
            INSERT INTO teav_ext_string (owner_oid, key, value) VALUES (id, 'other-key-' || r, 'other-value-' || r);
        ELSEIF r % 10 <= 4 THEN
            -- rarely used values of hobbies key
            hobbies := random_pick(ARRAY['recording', 'guitar', 'beer', 'rum', 'writing', 'coding', 'debugging', 'gaming', 'shopping', 'watching videos', 'sleeping', 'dreaming'], 0.1);
            -- JSONB
            INSERT INTO tjson (name, ext) VALUES (
                'user-' || LPAD(r::text, 10, '0'),
                ('{"eid": ' || r || ', "hobbies": '|| array_to_json(hobbies)::text || '}')::jsonb
            );

            -- EAV
            INSERT INTO teav (name) VALUES ('user-' || LPAD(r::text, 10, '0')) RETURNING oid INTO id;
            INSERT INTO teav_ext_string (owner_oid, key, value) VALUES (id, 'eid', r);
            FOREACH v IN ARRAY hobbies LOOP
                    INSERT INTO teav_ext_string (owner_oid, key, value)
                    VALUES (id, 'hobbies', v);
                END LOOP;
        ELSE
            -- these values are used by many entries
            hobbies := random_pick(ARRAY['eating', 'books', 'music', 'dancing', 'walking', 'jokes', 'video', 'photo'], 0.4);
            -- JSONB
            INSERT INTO tjson (name, ext) VALUES (
                'user-' || LPAD(r::text, 10, '0'),
                ('{"eid": ' || r || ', "hobbies": '|| array_to_json(hobbies)::text || '}')::jsonb
            );

            -- EAV
            INSERT INTO teav (name) VALUES ('user-' || LPAD(r::text, 10, '0')) RETURNING oid INTO id;
            INSERT INTO teav_ext_string (owner_oid, key, value) VALUES (id, 'eid', r);
            FOREACH v IN ARRAY hobbies LOOP
                INSERT INTO teav_ext_string (owner_oid, key, value)
                VALUES (id, 'hobbies', v);
            END LOOP;
        END IF;

        IF r % 1000 = 0 THEN
            COMMIT;
        END IF;
    END LOOP;
END $$;
----

== 15 million rows

Both JSON and EAV tables contain 15M rows, EAV extension detail table contains 45.8M rows.

|===
| Object | Size | Note

| teav_ext_string | 2763 MB | attribute value table (detail for EAV)
| teav_ext_string_pk | 2312 MB | PK of AV table, nearly the same size
| tjson | 1909 MB | JSON table (smaller than just AV table alone)
| tjson_ext_idx | 1620 MB | GIN index for `ext` column
| teav_ext_string_key_value_idx | 867 MB | index for searching by key+value
| teav | 862 MB | master table for EAV model
| teav_oid_pk | 583 MB | primary key index of that table
| tjson_oid_pk | 582 MB | PK of JSON table, virtually the same as for EAV
| teav_name_key, tjson_name_key | 451 MB | name indexes are the same
|===

Counts JSON:

|===
| Operation | Time avg (ms) | Note

| select count(*) from tjson | 6512 | seq-scan by default;
doesn't use PK index but if forced to, the time goes to ~2s;
some additional index on `(ext->>'...')` can be uses and time may drop to ~1.3s
| ... where ext @> '{"hobbies":["video"]}' | 8200 | seq-scan, low selectivity, matches 3.4M of 15M rows
| ... where ext @> '{"hobbies":["sleeping"]}' | 181 | high selectivity, matches ~50k rows, uses GIn index, Gather / Partial Aggregate / Parallel Bitmap Heap Scan on tjson / Bitmap Index Scan on tjson_ext_idx
| select count(*) from tjson where ext->>'email' LIKE 'user2%'; | 7174 | matches ~222k rows, seq-scan;
index `ON tjson ((ext->>'email'))` doesn't seem to help (not used, even after `ANALYZE`)
| where UPPER(ext->>'email') LIKE 'USER2%' | 7855 | like above with little overhead because of the function;
even ignores the index on (UPPER(ext->>'email'))
|===

Counts EAV:

|===
| Operation | Time avg (ms) | Note

| select count(*) from teav_ext_string | 6382 | informational, otherwise useless, for 15M `teav` rows returns ~47M rows
| select count(*) from teav | 2284 | seq-scan
| ... where exists (select from teav_ext_string es where es.owner_oid = t.oid and es.key = 'hobbies' and es.value = 'video')
| 17,465 | seq-scan, low selectivity
| ... where exists (select from teav_ext_string es where es.owner_oid = t.oid and es.key = 'hobbies' and es.value = 'sleeping')
| 1965 | Gather / Partial Aggregate / Nested Loop ( Parallel Bitmap Heap Scan on teav_ext_string / Bitmap Index Scan on teav_ext_string_key_value_idx, Index Only Scan using teav_oid_pk)
| ... where exists (select from teav_ext_string es where es.owner_oid = t.oid and es.key = 'email' and es.value LIKE 'user2%')
| 14,932 | very slow, seq-scan on ext table, `teav` PK used for semi-join (that's OK)
| ... where exists (select from teav_ext_string es where es.owner_oid = t.oid and es.key = 'email' and UPPER(es.value) LIKE 'USER2%')
| 11,869 | Aggregate / Nested Loop ( HashAggregate / Gather / seq-scan on the ext table, Index Only Scan using teav_oid_pk)
| select count(owner_oid) from teav_ext_string where key = 'email' and value LIKE 'user2%'
| ~7s | the same result for single-valued extension, hadly to be expected from query interpreter, still seq-scan
|===

[NOTE]
All selects have `LIMIT 500` for practical reasons (unless stated differently),
`pgbench` would try to read all the lines otherwise.

Selects - JSON:

|===
| Operation | Time avg (ms) | Note

| select * from tjson | 0.949 | doesn't need index
| ... where ext @> '{"hobbies":["video"]}' | 2.034 | doesn't need index
| ... order by oid | 6.32 | index scan `tjson_oid_pk` + filter
| ... and oid>'fffe0000-0000-0000-0000-000000000000' | 0.97 | PK index scan + index cond + filter,
this demonstrates the power of keyset pagination (this returns last "page", less than 500)
| select * from tjson where ext @> '{"hobbies":["sleeping"]}' | 44.94 | rare compared to "video",
may use `tjson_ext_idx` (GIN index) or seq-scan, both is OK, takes longer to find 500 values than for "video"
| ... order by oid | 92.34 | index scan `tjson_oid_pk` + filter; may also use `tjson_ext_idx` (both OK)
| where ext->>'email' LIKE 'user2%' | 2.25 | seq-scan; ignores the index on `((ext->>'email'))` even though it matches only 1.5% of the table
| ... order by oid | 90.7 | index scan `tjson_oid_pk` + filter
| ... and oid>'fffe0000-0000-0000-0000-000000000000' | 5.34 | bitmap index scan `tjson_oid_pk` + filter (why bitmap?)
| where UPPER(ext->>'email') LIKE 'USER2%' | 2.40 | seq-scan; ignores the functional index on `(upper(ext->>'email'))`
| ... order by oid | 95.0 | index scan `tjson_oid_pk` + filter
| ... and oid>'fffe0000-0000-0000-0000-000000000000' | 5.00 | index scan `tjson_oid_pk` + filter
| where cast(ext->'eid' as int) = 5000 | 8133 | seq-scan, inefficient version of the query bellow, don't use `=` where `@>` works better
| where ext @> '{"eid":5000}'; | 0.32 | Bitmap Index Scan on `tjson_ext_idx` + bitmap heap scan on tjson + recheck cond
|===

Selects - EAV:

|===
| Operation | Time avg (ms) | Note

| select * from teav | 0.494 | seq-scan
| select * from teav t where exists (select from teav_ext_string es where es.owner_oid = t.oid and es.key = 'hobbies' and es.value = 'video')
| 6.184 | index scan `teav_oid_pk` + seq-scan on ext table
| ... order by t.oid | 4.734 | index scan `teav_oid_pk` + index *only* scan `teav_ext_string_pk` (order accidentally helps to pick better plan here)
| ... and t.oid>'fffe0000-0000-0000-0000-000000000000' | 11.34 | index scan `teav_oid_pk` + index *only* scan `teav_ext_string_pk`
| select * from teav t where exists (select from teav_ext_string es where es.owner_oid = t.oid and es.key = 'hobbies' and es.value = 'sleeping')
| 24.28 | index scan `teav_oid_pk` + bitmap index scan on `teav_ext_string_key_value_idx` (higher selectivity for "sleeping")
| ... order by t.oid | 206 | index scan `teav_oid_pk` + bitmap index scan on `teav_ext_string_key_value_idx`
| ... where exists (select from teav_ext_string es where es.owner_oid = t.oid and es.key = 'email' and es.value LIKE 'user2%')
| 109 | index scan `teav_oid_pk` + index *only* scan `teav_ext_string_pk`
| ... order by t.oid | 108 | index scan `teav_oid_pk` + index *only* scan `teav_ext_string_pk` + merge semi join
| ... and t.oid>'fffe0000-0000-0000-0000-000000000000' | 78.1 | index scan `teav_oid_pk` + index *only* scan `teav_ext_string_pk` + gather merge / sort
| ... where exists (select from teav_ext_string es where es.owner_oid = t.oid and es.key = 'email' and UPPER(es.value) LIKE 'USER2%')
| 117 | index scan `teav_oid_pk` + index *only* scan `teav_ext_string_pk`
| ... order by t.oid | 116 | index scan `teav_oid_pk` + index *only* scan `teav_ext_string_pk` + merge semi join
| ... and t.oid>'fffe0000-0000-0000-0000-000000000000' | 90.6 | index scan `teav_oid_pk` + index *only* scan `teav_ext_string_pk` + gather merge / sort
| where exists (select from teav_ext_string es where es.owner_oid = t.oid and es.key = 'eid' and es.value = '5000')
| 0.500 | index scan `teav_oid_pk` + index scan `teav_ext_string_key_value_idx`
|===

== Performance with more RAM/CPU

After resizing the VirtualBox, the following parameters were used (uninformed setup using https://pgtune.leopard.in.ua/[this site]):
----
# DB Version: 13
# OS Type: linux
# DB Type: oltp
# Total Memory (RAM): 8 GB
# CPUs num: 4
# Connections num: 100
# Data Storage: ssd

max_connections = 100
shared_buffers = 2GB
effective_cache_size = 6GB
maintenance_work_mem = 512MB
checkpoint_completion_target = 0.9
wal_buffers = 16MB
default_statistics_target = 100
random_page_cost = 1.1
effective_io_concurrency = 200
work_mem = 10485kB
min_wal_size = 2GB
max_wal_size = 8GB
max_worker_processes = 4
max_parallel_workers_per_gather = 2
max_parallel_workers = 4
max_parallel_maintenance_workers = 2
----

Most of these are already commented out by default in `postresql.conf`, the rest was commented too,
not to collide with the added section above.
Benchmark was run a couple of times first to warm up the DB before results were used.

|===
| Operation | 2GB/1CPU (ms) | 8GB/4CPU (ms)

| select count(*) from tjson | 6512 | 1567
| ... where ext @> '{"hobbies":["video"]}' | 8200 | 1388
| ... where ext @> '{"hobbies":["sleeping"]}' | 181 | 57.5
| select count(*) from tjson where ext->>'email' LIKE 'user2%'; | 7174 | 777
| where UPPER(ext->>'email') LIKE 'USER2%' | 7855 | 1196
| select count(*) from teav_ext_string | 6382 | 5793
| select count(*) from teav | 2284 | 1175
| ... where exists (select from teav_ext_string es where es.owner_oid = t.oid and es.key = 'hobbies' and es.value = 'video')
| 17,465 | 4958
| ... where exists (select from teav_ext_string es where es.owner_oid = t.oid and es.key = 'hobbies' and es.value = 'sleeping')
| 1965 | 259
| ... where exists (select from teav_ext_string es where es.owner_oid = t.oid and es.key = 'email' and es.value LIKE 'user2%')
| 14,932 | 2646
| ... where exists (select from teav_ext_string es where es.owner_oid = t.oid and es.key = 'email' and UPPER(es.value) LIKE 'USER2%')
| 11,869 | 2282
| select * from tjson limit 500 | 0.949 | 0.734
| ... where ext @> '{"hobbies":["video"]}' | 2.034 | 1.873
| ... order by oid | 6.32 | 2.425
| ... and oid>'fffe0000-0000-0000-0000-000000000000' | 0.97 | 0.761
| select * from tjson where ext @> '{"hobbies":["sleeping"]}' | 44.94 | 41.82
| ... order by oid | 92.34 | 58.79
| where ext->>'email' LIKE 'user2%' | 2.25 | 1.93
| ... order by oid | 90.7 | 23.19
| ... and oid>'fffe0000-0000-0000-0000-000000000000' | 5.34 | 0.59
| where UPPER(ext->>'email') LIKE 'USER2%' | 2.40 | 2.19
| ... order by oid | 95.0 | 25.2
| ... and oid>'fffe0000-0000-0000-0000-000000000000' | 5.00 | 0.65
| where ext @> '{"eid":5000}'; | 0.32 | 0.25
| select * from teav limit 500 | 0.494 | 0.419
| ... where exists (select from teav_ext_string es where es.owner_oid = t.oid and es.key = 'hobbies' and es.value = 'video')
| 6.184 | 2.893
| ... order by t.oid | 4.734 | 2.639
| ... and t.oid>'fffe0000-0000-0000-0000-000000000000' | 11.34 | 6.045
| ... where exists (select from teav_ext_string es where es.owner_oid = t.oid and es.key = 'hobbies' and es.value = 'sleeping')
| 24.28 | 3.369
| ... order by t.oid | 206 | 65.1
| ... where exists (select from teav_ext_string es where es.owner_oid = t.oid and es.key = 'email' and es.value LIKE 'user2%')
| 109 | 40.6
| ... order by t.oid | 108 | 35.7
| ... and t.oid>'fffe0000-0000-0000-0000-000000000000' | 78.1 | 21.9
| ... where exists (select from teav_ext_string es where es.owner_oid = t.oid and es.key = 'email' and UPPER(es.value) LIKE 'USER2%')
| 117 | 39.3
| ... order by t.oid | 116 | 39.0
| ... and t.oid>'fffe0000-0000-0000-0000-000000000000' | 90.6 | 21.4
| where exists (select from teav_ext_string es where es.owner_oid = t.oid and es.key = 'eid' and es.value = '5000')
| 0.500 | 0.468
|===
