= Mappings
:page-wiki-name: Mapping
:page-wiki-id: 5931015
:page-wiki-metadata-create-user: semancik
:page-wiki-metadata-create-date: 2012-09-18T11:01:45.947+02:00
:page-wiki-metadata-modify-user: semancik
:page-wiki-metadata-modify-date: 2020-11-18T15:35:10.215+01:00
:page-display-order: 70
:page-upkeep-status: red
:page-toc: top


== Introduction

_Mapping_ is a mechanism that is used at many places through midPoint to map value of a source property (or properties) to a target property.
It is a very flexible mechanism that allows to use expressions (including scripting), direct variable references, value generators and other _evaluators_ for the value.
It is used for example in xref:/midpoint/reference/expressions/mappings/outbound-mapping/[outbound mapping], xref:/midpoint/reference/expressions/mappings/inbound-mapping/[inbound mapping], xref:/midpoint/reference/roles-policies/assignment/[assignments], xref:/midpoint/reference/roles-policies/rbac/[roles] and so on.

.Reference documentation
NOTE: This is a reference documentation, explaining all the details and complexities.
It is intended for engineers with some experience with midPoint and mappings.
This documentation is meant to explain all the principles of midPoint mappings, leading to deeper understanding.
This documentation may not be suitable for beginners.
xref:/book[MidPoint book] may be a good starting point instead.


== Basic Structure

Mapping consists of four basic parts:

* *Source* part defines the data sources of the mapping.
These are usually understood as mapping input.
Source defines where mapping gets its data from.

* *Expression*, *condition* control data transformation.
This part controls the way data are transformed or generated.
This is usually the most flexible part of the mapping, employing short scripts.
There is a broad variety of possibilities that are described in the xref:/midpoint/reference/expressions/expressions/[Expression] page.

* *Condition*, *constraints* and some other settings control data flow.
This part influences whether the data will flow at all, when they will flow, at what time, under which conditions.

* *Target* part defines what to do with the results of the mapping, where the computed values should go.
This part also controls how the mapping output should be used in relation to other values.

The basic parts of the mapping as well as the basic principle is illustrated in the following figure:

image::mapping-complete.png[]

The figure shows a mapping that takes `givenName` and `familyName` values from user to compute a `cn` attribute of an account.

The mapping is using a Groovy expression to concatenate the two values with a space in the middle.
There is also a condition that makes sure the mapping is applied only if it has meaningful inputs.

The mapping is represented in the JSON/XML form as follows:

[source,json]
----
{
    "mapping" : {
        "source" : [
            {
                "path" : "$focus/givenName"
            },
            {
                "path" : "$focus/familyName"
            }
        ],
        "expression" : {
            "script" : {
                "code" : "givenName + ' ' + familyName"
            }
        },
        "condition" : {
            "script" : {
                "code" : "givenName != null &amp;&amp; familyName != null"
            }
        },
        "target": {
            "path" : "$projection/attributes/cn"
        }
    }
}
----


[source,xml]
----
<mapping>
    <source>
        <path>$focus/givenName</path>
    </source>
    <source>
        <path>$focus/familyName</path>
    </source>
    <expression>
        <script>
            <code>givenName + ' ' + familyName</code>
        </script>
    </expression>
    <condition>
        <script>
            <code>givenName != null &amp;&amp; familyName != null</code>
        </script>
    </condition>
    <target>
        <path>$projection/attributes/cn</path>
    </target>
</mapping>
----

Mappings are xref:mapping-relativity/[relativistic], reactive to changes in mapping sources in a smart way.

NOTE: This mapping that takes user's `givenName` and `familyName` to produce `cn` of an account should be considered only an example, an illustration, not a best practice.
Computing `cn` attribute in such a direct way is not a good idea.
In most cases, `givenName` and `familyName` should be used to compute user's `fullName`, which should be a used as a source for `cn` mapping.


== Sources

Sources form primary inputs for a mapping.
Mapping source definitions point to data items that the mapping works with.
The mapping will react to changes of source data, triggering re-evaluation of the mapping.

The most important part of mapping source definitions is specification of the xref:/midpoint/reference/concepts/item-path/[item path].
The path refers to an item in an object, which is part of xref:/midpoint/reference/concepts/clockwork/clockwork-and-projector/[clockwork/project] computation, which is usually a _focus_ or a _projection_.

.Mapping source definition
[source,json]
----
{
    "source" : {
        "path" : "$focus/familyName"
    }
}
----

.Mapping source definition
[source,xml]
----
<source>
    <path>$focus/familyName</path>
</source>
----

For the mapping to operate correctly, the sources must point to an object appropriate for the clockwork phase in which the mapping is evaluated.
E.g. source of _inbound_ mapping must point to a _projection_, source of _outbound_ mapping must point to a focus.
The appropriate object is usually set up as _default context_ for the mapping, which means that relative item paths should be conveniently used to point to appropriate object:

.Mapping source definition (relative path)
[source,json]
----
{
    "source" : {
        "path" : "familyName"
    }
}
----

.Mapping source definition (relative path)
[source,xml]
----
<source>
    <path>familyName</path>
</source>
----

More details about mapping context is provided below.

=== Relativity of Sources

Mappings are xref:mapping-relativity/[relativistic] in several ways.
Mappings will react to changes in source values, triggering re-evaluation of mappings as needed.
In the above example, the mapping will be re-evaluated if either of the sources change (`givenName` or `familyName`), or in case that full recompute is requested (e.g. in case of full reconciliation).
In case that neither of the sources have changed there is no need to re-evaluate that mapping.

However, midPoint assumes that re-evaluation of mapping is usually cheap, assuming we have all the input data ready.
Therefore, midPoint may re-evaluate the mapping even in case that neither of the sources have changed, as it helps to make sure that the data are still consistent.

Smart reaction to changes is one of the reasons for requiring explicit definition of sources in the mappings.
Without such definitions it is not (realistically) possible to reliably determine how and when the expression should be re-evaluated.

The sources themselves are delta-aware.
The source does not specify the value only, it also specifies previous value, and the way how the value changed (xref:/devel/prism/concepts/deltas/[delta]).
This allows mapping to be smart, re-computing only some values.
Even more importantly, source deltas are taken into consideration when mapping is evaluated.
Therefore, mapping can figure out how target value have changed, and apply the changes in a smart way (see xref:mapping-relativity/[]).

Mappings can have several sources, each of the sources can have many values.
All the values of all the sources are taken into consideration when a mapping is evaluated.

=== Source Name

Mapping sources are specified using xref:/midpoint/reference/concepts/item-path/[item path], which may be quite long and complex.
Yet, almost all the scripting languages require simple strings to denote variables, parameters and inputs.
Therefore, each source has assigned a simple name.
The name is derived from the last segment of item path of the source.
Hence a source with path of `$focus/activation/administrativeStatus` will be accessible as `administrativeStatus` in the scripts.
The two sources in the above example are passed to the expression as a variables with names `givenName` and `familyName` respectively.

Automatic derivation of source name usually works well.
However, there is `administrativeStatus` in `$focus/activation/administrativeStatus`, but also on `$focus/assignment/activation/administrativeStatus`.
If both of them are used as two sources of one mapping, one of them has to be renamed.

For that purpose, source definition has one additional element: a name.
The `name` element explicitly specifies the name that the source will take when used as an expression variable:

.Explicit specification of source name
[source,json]
----
{
    "source" : {
        "name" : "lastName",
        "path" : "$focus/familyName"
    }
}
----

.Explicit specification of source name
[source,xml]
----
<source>
    <name>lastName</name>
    <path>$focus/familyName</path>
</source>
----

This source will be accessible under the name `lastName` in the mapping expression.

In some cases, the primary input to an expression is accessible under name `input`.
This approach is applied in cases when there is only a single source for a mapping (by definition), such as _inbound_ mappings applied to a single attribute.
Similar approach is applied to stand-alone expression, where there is no obvios name for expression input.


=== Mapping Domain

++++
{% include since.html since="3.5.1" %}
++++


The _domain_ of a mapping (in a mathematical sense) is a set of values that are valid inputs of the mapping.
The mapping will operate only on the values that belong to its domain.
Other values will be ignored.
By default, the mapping has unlimited domain: all possible values are processed by the mapping.
The mapping domain can be specified by using a `set` declaration in its source:

.Specification of mapping domain
[source,xml]
----
    <mapping>
        <authoritative>true</authoritative>
        <source>
            <path>organization</path>
            <set>
                <condition>
                    <script>
                        <code>basic.stringify(organization)?.startsWith("AUTO-")</code>
                    </script>
                </condition>
            </set>
        </source>
        <expression>
            ...
        </expression>
        <target>
            <path>assignment</path>
        </target>
    </mapping>
----

The above mapping will only operate on input values that starts with `AUTO-`.
Other values will be ignored by the mapping.

The domain definition is a very practical mechanism if there are several mappings that work on the same source and/or target, each of the mappings using a different expression.
In this case mapping domains can be set in such a way that they do not overlap, making sure only one of the mapping is processing any particular value.
Domain is also useful if we want to provide output values only for some input values.
This cannot be easily achieved by using mapping condition, as the condition will activate or deactivate entire mapping, it applies to all the values processed by a mapping.
The condition does not work for individual values.

The domain is very useful especially for automatic xref:/midpoint/reference/roles-policies/assignment/[assignment] expressions in xref:/midpoint/reference/expressions/object-template/[object template].


== Target

Mapping target specifies were and how is the output of a mapping used.
Specification of mapping target is much more than a mere assignment of mapping output value to some property.
The target _binds_ output property to the mapping, it indirectly specifies the type of output values, its multiplicity, it may also imply set of valid output values.
The nature of mapping target influences the way how relative changes are processed and how deltas are formed.
Mapping range specified together with the target is a powerful tool to influence other values of target item.
All in all, understanding how mapping is bound to its target is a crucial aspect in understanding how mappings work.

Formally, target definition is very similar to definition of mapping source.
The most important part is _item path_, binding the mapping to the target item.


.Mapping target definition
[source,json]
----
{
    "target" : {
        "path" : "fullName"
    }
}
----

.Mapping target definition
[source,xml]
----
<target>
    <path>fullName</path>
</target>
----

Unlike mapping sources, there can be only one mapping target.


=== Mapping Range

++++
{% include since.html since="3.6" %}
++++

The _range_ of a mapping (in a mathematical sense) is a set of values that are considered to be valid outputs of the mapping.
Definition of mapping range is not important for evaluation of mapping expression.
However, it is important for application of mapping outputs.

The mapping is considered to be authoritative for all values in its range.
If the target item contains values that belong to the mapping range, it is assumed that the values were created by the mapping.
I.e. if the mapping contains any values that belong to the mapping range, and the mapping does not produce such values as its output, the values are removed.

The range defines what are the possible outputs of the mapping.
The xref:/midpoint/reference/concepts/clockwork/clockwork-and-projector/[projector] can use this information to determine what values to remove when the mapping is authoritative.

The range definition does *not* influence mapping inputs or expression.
The range is used when the mapping outputs are processed.

Please see xref:range/[] for detailed explanation of mapping range concepts.

== Default Sources and Targets

// TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO


TODO: sources and targets for inbound/outbound

[%autowidth,cols="h,1,1,1,1"]
|===
| Mapping |  | Variables | Default Context | Examples

| Outbound
| Source
| $focus +
$projection
| $focus
| $focus/givenName +
givenName

| Outbound
| Target
| N/A +
fixed to account attribute
| N/A +
fixed to account attribute
|

| Inbound
| Source
| N/A +
fixed to account attribute, presented as `input` variable
| N/A +
fixed to account attribute
|

| Inbound
| Target
| $focus +
$projection
| $focus
| $focus/givenName +
givenName

| User template
| Source
| $focus
| $focus
| $user/givenName +
givenName

| User template
| Target
| $focus
| $focus
| $focus/givenName +
givenName

|===



== Variables

Variables are secondary inputs to the mapping.
Variables provide information about the _surroundings_ of the mapping, about the environment in which the mapping evaluates.
For example, _inbound_ mapping usually takes information from account attribute on a source system (resource) to produce a value for user property.
The account attribute is mapping source, and the user property is a target.
However, mapping may need to consider other data as well, such as a definition of the resource or global system configuration.
Mapping variables provide such additional information.

Sources behave in a slightly similar way than variables behave, especially in mappings with scripting expressions.
Mapping variables are provided as variables or parameters in the script code, in much the same way as sources are provided.
Variable data may also be delta-aware.
However, there are crucial differences between variables and sources.
Changes in variable values may not trigger mapping re-evaluation and the deltas of variables are not reflected to mapping output in the same way as source deltas are.

Please see xref:../variables/[] page for the details.

// TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO




== Expressions

TODO: scripting expressions and multiple multi-valued sources




Because expressions are so flexible they are documented in a separate xref:/midpoint/reference/expressions/expressions/[Expression] page.



== TODO: OLD text







== Expression

Expression is the part of the mapping that contains transformation logic.
It can contain a script expression, direct path expression, fixed value expression, generator or other expression type.
There are many possibilities and they are described in xref:/midpoint/reference/expressions/expressions/[Expression] page.

All expression types work with _variables_ as an input.
Mapping is passing all the _sources_ as expression variables.
The variable names are either implicitly derived or explicitly specified as described above.
Also all the other context variables are passed to an expression.
But there is a slight difference how expression handle sources and other variables.

The return value of an expression is used as value for the target.


== Constraints and Condition

The application of a mapping can be affected by using constraints and condition.
These mechanisms can influence when the mapping is applied and when it is not.


condition will activate or deactivate entire mapping, it applies to all the values processed by a mapping.
The condition does not work for individual values.

=== Constraints

Constraints limit the use of a mapping only to certain situations.
In such a situation the mapping is applied as usual in other situations the system will pretend that the mapping is not there.

The only applicable constraint is currently *channel constraint*. Application of a mapping can be limited to a specific xref:/midpoint/reference/concepts/channel/[channel]. If the evaluation is done in the context of that channel the mapping will be applied.
If the channel is different the system will ignore the mapping.
This constraint is usually used in xref:/midpoint/reference/expressions/mappings/inbound-mapping/[inbound mappings] to limit them to the import channel and therefore use them only for initial import.

.Channel constraint example
[source,xml]
----
<inbound>
    <strength>strong</strength>
    <channel>http://midpoint.evolveum.com/xml/ns/public/provisioning/channels-3#import</channel>
    <expression>
    ...
    </expression>
    ...
</inbound>
----

Other constraints will be most likely added in the future.


=== Time Constraints

Special category of constrains are time constraints.
The presence of a time constraint limits the applicability of a mapping to a specific time.
There are two time constraints: `timeFrom` and `timeTo`. These limits the applicability of the mapping to a specified mapping interval.
If the current time is in the interval the mapping will be applied normally.
If the time is outside the interval then the mapping will be ignored.

The mapping below will be applied only in time interval that starts 10 day after the `disableTimestamp` and ends 3 months after `disableTimestamp`.

.Time-constrained mapping
[source,xml]
----
<mapping>
    <timeFrom>
        <referenceTime>
            <path>activation/disableTimestamp</path>
        </referenceTime>
        <offset>P10D</offset>
    </timeFrom>
    <timeTo>
        <referenceTime>
            <path>activation/disableTimestamp</path>
        </referenceTime>
        <offset>P3M</offset>
    </timeTo>
    <expression>
        <asIs/>
    </expression>
</mapping>
----

Each time constraint has two parts:

* `referenceTime` specified the quasi-fixed point in time.
This is a kind of a time-wise "base" for the mapping.
The reference time is specified as a path (pointer) to a property that holds the actual timestamp.

* `offset` specifies a time interval relative to the reference time.
It can be positive or negative.
It is specified in link:https://www.w3schools.com/xml/schema_dtypes_date.asp[XSD duration data type format (ISO 8601)]. The offset is applied to the reference time to get a final time.

Any combination of `timeFrom` and `timeTo` can be present in a mapping (none of them, any of them, both of them).

The mapping time constraint are slightly more that just mapping evaluation constraints.
The presence of a time constraint does not only limits the evaluation of a mapping but it usually also makes sure that the mapping will be re-evaluated at the right time.
MidPoint is using a system of triggers to make sure the mappings for re-evaluation are located quickly and efficiently.
Therefore it is much better to use a time constraint instead of simple mapping condition.

[TIP]
.Why do we need reference time?
====
The mappings are usually evaluated when a change happens.
It may be tempting to try to use current time of the evaluation as a reference time.
E.g. specifying something like "10 days after the account status was evaluated to be `disabled`.
However there are cases when the mapping is evaluated or re-evaluated much later, e.g. in case of reconciliation or recompute.
If we would use the current time of evaluation the result of evaluation may be different each time we re-evaluate the mapping.
E.g. in the "10 days after `disabled` " case the notion of "10 days after" may change each time the mapping is evaluated.
Such approach will setting it to 10 days from the current time every time it is re-evaluated.
Therefore  we usually cannot just use the current time of mapping evaluation as a reference.
We want to use something more stable instead.
Enable/disable timestamps which are stored in midPoint repository are usually good candidates.
Or even create/modify timestamps from the object metadata.
Using such values for reference time will make sure the result of the mapping evaluation is consistent even if it is re-evaluated.
====


==== Time Constraint Expressions

++++
{% include since.html since="4.0" %}
++++

The timestamp to be used for the time constraint can be determined by an expression.
E.g. scripting expressions can be used to set the time constraint in a very flexible manner:

[source,xml]
----
    <mapping>
        <timeFrom>
            <expression>
                <script>
                    <code>
                        def createTimestamp = focus?.metadata?.createTimestamp
                        def timestamp = basic.addDuration(createTimestamp, "P3M")
                        return basic.roundDownToMidnight(timestamp)
                    </code>
                </script>
            </expression>
        </timeFrom>
        ...
    </mapping>
----

The expression above returns a timestamp that is based on object creation timestamp, delayed by three months and rounded down to the midnight.

If referenceTime specification is used together with expression, the reference time value will be passed to the expression in `referenceTime` variable.
If both expression and offset are used, the offset is applied to the timestamp produced by the expression.
If the expression returns null then the time constraint will be considered unsatisfied.
Which is a similar behavior as if reference time was not set.


=== Condition

Condition is a special kind of xref:/midpoint/reference/expressions/expressions/[expression] in the mapping that influences whether the mapping will be applied or not.
If a condition evaluates to `true` value the mapping will be applied.
If it evaluates to `false` then the mapping is not considered to be active.
The condition can be used to set conditional property values, conditionally assign roles, define mapping constraints and so on.

For example an condition may be used in the mapping to apply the mapping only if the input value is non-empty:

[source,xml]
----
<inbound>
    <expression>...</expression>
    <target>...</target>
    <condition>
        <script>
            <code>basic.isEmpty(input)</code>
        </script>
    </condition>
</inbound>
----

One condition per mapping can be defined.

The processing of a condition fully supports the relative change model.
Therefore the system accounts for conditions being flipped (true-to-false or false-to-true) and will reflect that in a mapping result.
E.g. if an value is by a mapping that used to have `true` condition but that changed to `false` the system will generate appropriate deltas to remove such value.
Therefore the mapping is ideal to give and remove target values.

[source,xml]
----
<inbound>
    <expression>...expression that assigns a role...</expression>
    <target>assignment</target>
    <condition>
        <script>
            <code>hrJobCode == "1234"</code>
        </script>
    </condition>
</inbound>
----

The mapping above adds the assignment when `hrJobCode` is `1234` and removes the assignment when the code is different.
This is a very useful behavior.
However, especially when working with assignments, it may be slightly difficult to do properly.
If there are several ways how the target can be modified then it is crucial to correctly set up mapping range (see below).
Mapping range will be applied even if mapping condition evaluates to `false`. The range controls how "authoritative" the mapping is, and the mapping will not stop to be authoritative just because the condition evaluates to `false`. This approach also provides the most flexible approach, allowing midPoint to handle variety of cases with just a couple simple mechanisms.

[NOTE]
.Conditions and ranges in midPoint 4.0 and earlier
====
In midPoint 4.0 and earlier, the mapping range was *not* applied consistently when the condition was `false`. Some mappings in some cases applied the range, other mappings did not.
This was incorrect behavior (bug) and it was corrected in midPoint 4.1.

The incorrect behavior was perhaps based on the approach that if the condition evaluates to `false` then the system will "pretend that the mapping does not exist at all".
This was even documented in this page in earlier versions of midPoint.
However, this approach was a leftover from the times when midPoint did not have mapping ranges and the documentation was incorrect.
We understand that some deployments relied on this behavior and we would like to apologize for any inconvenience.
However, our policy is not to maintain "compatible bugs", therefore we have corrected the behavior of mappings in all the places to make midPoint behavior consistent.

If you need to "turn off" the mapping completely, the proper way is to set the condition both in the `condition` part of the mapping and in the range specification, i.e. making the mapping non-authoritative (having empty range) when the condition is false.
====


== Examples

Following example provides xref:/midpoint/reference/expressions/mappings/outbound-mapping/[outbound] mapping that is using xref:/midpoint/reference/expressions/introduction/[script expression] written in Groovy language.
The expression concatenates two string literals and the value of `name` property from the `user` variable.
The mapping in _weak_ which means it will only be applied if there is no value already present (it constructs _default_ value).

.Example of outbound mapping
[source,xml]
----
<attribute>
    <ref>icfs:name</ref>
    ...
    <outbound>
        <strength>weak</strength>
        <source>
            <name>name</name>
            <path>$user/name</path>
        <source>
        <expression>
            <script>
                <code>
                    'uid=' + name + ',ou=people,dc=example,dc=com'
                </code>
            <script>
        </expression>
    </outbound>
    ...
</attribute>
----

The mapping is using explicit _source_ definition.
This tells the mapping that `$user/name` is an input to the mapping and that any change of `name` property of a user has to be reflected to the target attribute using specified Groovy expression.
The target is not explicitly specified here as it is clear from the placement of the _outbound_ mapping inside a _schemaHandling_ part.

.Example of inbound mapping
[source,xml]
----
<attribute>
    <ref>ri:businessCategory</ref>
    ...
    <inbound>
        <expression>
            <script>
                <code>
                    input.toLowerCase()
                </code>
            <script>
        </expression>
        <target>
            <path>$user/employeeType</path>
        </target>
    </inbound>
    ...
</attribute>
----

Following simple example illustrates mapping of a literal value.
It is an _attribute_ mapping that may be used e.g. in role or assignment.
It constructs a value of account attribute `title`. The value is explicitly defined as a literal (_Bloody Pirate_).

.Mapping used to construct a literal attribute value
[source,xml]
----
<accountConstruction>
    ...
    <attribute>
        <ref>ri:title</ref>
        <outbound>
            <expression>
                <value>Bloody Pirate</value>
            </expression>
        </outbound>
    </attribute>
    ...
</accountConstruction>
----

The mapping has to explicitly specify _target_ as that is not clear from the placement of the mapping definition.
It does not need to specify any _source_ because the value is literal and does not depend on any input.

.Example of user template mapping
[source,xml]
----
<mapping>
    <source>
        <path>$user/givenName</path>
    </source>
    <source>
        <path>$user/familyName</path>
    </source>
    <expression>
        <script>
            <code>givenName + ' ' + familyName</code>
       </script>
    </expression>
    <target>
        <path>$user/fullName</path>
    </target>
</mapping>
----

// TODO: conditional mapping example

See also xref:/midpoint/reference/expressions/mappings/mapping-evaluation-examples/[Mapping Evaluation Examples] page.


== Expression Evaluators

See xref:/midpoint/reference/expressions/expressions/[Expression] page.


== Mapping Options

Mapping options modify the way how the mapping is used when constructing properties and attributes.
They do not influence how the value is computed, e.g. they do not influence evaluation of the expressions.
The options may specify that the value is more important that others, that is has to be used as a default, etc.


=== Mapping Strength

Strength of the mapping defines how aggressively will the mapping be applied.
The strongest mappings are applied all the time (regardless of the consequences) and the weakest mappings are applied only if nothing else can be applied.
Following table summarizes mapping strengths.

[%autowidth,cols="h,1,1,1"]
|===
| Strength | Description | Use in operations | Use in reconciliation

| Strong
| Always applied, regardless of context.
Strong mappings _enforce_ particular values.
| Mapping is always used.
The value from mapping is merged with any other deltas for the same target.
This may cause errors, e.g. if user requested to set a different value that the mapping sets for a single-value attribute.
| The value produced by mapping is required to be present in the target property.
If it is not then reconciliation will add it.


| Normal
| Apply the mapping unless there is a more specific change.
| Mapping is used unless user requested a more specific change.
E.g. Mapping from user's fullName to an account will be normally used to set account attribute `cn`. But this mapping will not be applied if the administrator explicitly specifies a different value for the attribute `cn`.
| Mapping is used in reconciliation only if the target attribute does not have any value.
The information whether administrator provided a more specific value is not present during reconciliation any more.
Therefore the mapping cannot be reliably applied if the attribute already has a value.


| Weak
| Apply the mapping only if there is a no other change on target property and the target property does not have any value.
This mapping strength is use to set initial (default) values for attributes and properties.
| Mapping will *not* be used if the target already has a value or if user has requested a any other change.
| Mapping is used in reconciliation only if the target attribute does not have any value.

|===

Unless otherwise specified the default strength of a mapping is *normal*.

[TIP]
.Mappings and reconciliation
====
Please note that the only mappings that will reliably overwrite a value during reconciliation are *strong* mappings.
Weak and normal mappings will not overwrite or delete a value.
This may be a slightly surprising behavior of normal mappings, but this is done by purpose.
Normal mappings are based on processing relative changes.
But during reconciliation there is no change in the source data.
Therefore there is also no reason to apply normal mappings.

Normal-strength mappings are the default setting in midPoint.
As usual, midPoint has conservative default settings that try to avoid destroying the values on target systems.
This is a good setting when midPoint is deployed, new systems are connected or when midPoint operates in semi-authoritative mode.
But once the midPoint is fully authoritative and the policies are properly defined and tested the mappings are usually switched to `strong` setting.
====


=== Exclusive Strong

When set to false then both strong and normal mapping values are merged to produce the final set of values.
When set to true only strong values are used if there is at least one strong mapping.
Normal values are used if there is no strong mapping.

The default value for exclusiveStrong flag is *false*.


=== Authoritative

Authoritative flag controls the way how mapping is used to *remove* values.
It does not influence adding of values.
If mapping is authoritative then it will add value and also remove the value.
If mapping is not authoritative it will only add the value.

Non-authoritative mappings are used if there are several possible sources for a particular value.
E.g. the value may be added by the mapping and also added directly on the resource by system administrator.
In this case midPoint cannot remove the value when the assignment (or role) containing the mapping is removed because the value might have been added manually.
Other settings, such as _tolerance_ may apply on attribute level.

The default value for authoritative flag is *true*.


=== Exclusive

Exclusive mapping may be applied only as a single mapping for a particular target property.
If an exclusive mapping is applied together with any other mapping it results in an error.

The default value for exclusive flag is *false*.


=== Tolerant

WARNING: Mapping `tolerant` setting was an experimental setting in old versions of midPoint.
When set to true, it allowed attribute/property values that are set outside of the mapping.
It was completely replaced by the _range_ mechanism.
The `tolerant` setting was removed in midPoint 4.0.

=== Channel

Limits application of this mapping only to specific channel.
If the channel is listed then the mapping will be applied.
If it is not then it will not be applied.
If no channel is specified then no limitations apply and the mapping will be applied for all channels.


=== Except Channel

Limits application of this mapping except for channel specified.
If the channel is listed then the mapping will be not applied in this channel.
If it is not then it will be applied.
If no channel is specified then no limitations apply and the mapping will be applied for all channels.


=== Range

Specifies the range of the mapping (in mathematical sense).
I.e. this specifies the values that the mapping can produce.
Range specification makes sense only for authoritative mappings.
If the range is specified then the mapping will scan existing values of the target property. +
It will look for values that are there and that are also in the range of the mapping.
If such values are not in the expression results, then such values will be removed (placed in the minus set).


=== Time From

TODO: Describe it.


=== Time To

TODO: Describe it.


=== Mapping State Properties

++++
{% include since.html since="4.0" %}
++++


Mappings can have state properties that are maintained through entire execution of the mappings.
Those properties are shared by all the expressions in the mapping.
The properties can be accessed by the scripts in the mapping:

[source,xml]
----
                <outbound>
                    <source>
                        <path>title</path>
                    </source>
                    <expression>
                        <script>
                            <code>
                                ...
                                midpoint.getMapping().setStateProperty("reduceRange", true)
                                ...
                            </code>
                        </script>
                    </expression>
                    <target>
                        <set>
                            <condition>
                                <script>
                                    <code>
                                        if (midpoint.getMapping().getStateProperty("reduceRange")) {
                                            ....
                                        }
                                    </code>
                                </script>
                            </condition>
                        </set>
                    </target>
                </outbound>
----


== Mapping Evaluation Order

It is possible to define more mappings that affect single attribute.
For example, one mapping can be defined as inbound mapping in schemaHandling of specific resource and another one can be defined separately in objectTemplate.
In similar cases, mappings are evaluated in this order:

*inbound mappings => objectTemplate => activation => assignments + roles + outbound mappings => reconciliation*

Which mappings will be applied to specific parameter during mapping evaluation can be easily modified using mapping strength options and mappings based on conditions.

When defining multiple mappings for single-valued attribute, every next applied mapping in order rewrites the value of attribute.
Be sure to check, if this is what you want.
In case of multiple-value attributes, mappings simply add next values to the attribute values list.



== Handling Multiple Values

The mapping mechanism is designed to be easy to use both for single-value properties and multi-value properties.
The single-value case is quite straightforward: the (single) value is passed to mapping as an input.
If there is no value then `null` is passed.
The mapping is supposed to produce (single) value.
That value is stored to target.
If no value or null is produced then it is assumed that the target should have no value.
That's all easy.

However, it all gets much more complex when multiple values are used.
But most of the complexity is hidden inside midPoint.
The mappings are deliberately designed in such a way that the mapping expression will be invoked for each input value individually.
Therefore if the input has three values, then the expression will be invoked three times: once for each input value.
The expression is supposed to produce output value - or even more values.
All the output values are collected together.
And this collection will be applied to the mapping target.

Therefore mapping expression still works with single-value input and output - even in the case of multi-value properties.
MidPoint will execute the expression as many times as needed and feed in each individual value.
The responsibility of the expression is to transform that specific value.

One-to-one value mapping is the usual case both in single-value and multi-value cases.
One input value usually translates to one output value.
No input value usually translates to no output value.
But midPoint mappings can also handle the unusual cases.
Input value may be translated to no output value.
The expression just need to return no value (`null` or empty list).
One input value may also be translated to several output values.
In that case the expression should return list of values.
MidPoint will process the result and collect the values.
This is all easy to do when expression is evaluated separately for each input value.

There is one special case when multiple values have to be transformed to single value or a different number of values.
The usual evaluate-per-input-value approach will not work here.
The _absolute_ evaluation mode can be used in this case.
The absolute evaluation mode means that that list of all values is passed to the expression as input.
In this case the expression is supposed to produce a list of all output values.

The description above mostly applies to xref:/midpoint/reference/expressions/expressions/script/[script expressions]. Other expression types can deal with multi-value properties in a very natural way.
Such as `asIs` expressions that simply copy the input to the output regardless of the number of values.
But even non-script expressions have behavior similar to the mechanism described above.
For example `assignmentTargetSearch` expressions will handle multi-valued input in the same way: it will execute search filter for each value individually and it will collect the results.


== Relativity

Evaluation of each value separately is a very convenient from a configuration and customization point of view.
However, there is even a much deeper reason for this approach.
Evaluation of each value individually supports midPoint's xref:/midpoint/reference/concepts/relativity/[relativity principle]. This is best explained using an example.
Let's have a mapping that transforms all input values to upper case:

[source,xml]
----
<mapping>
    <source>
        <path>invar</path>
    </source>
    <expression>
        <script>
            <code>invar.toUpperCase()</code>
        </script>
    </expression>
    <target>
        <path>outvar</path>
    </target>
</mapping>
----

Let's assume that both `invar` and `outvar` are multi-valued.
This is the case when the relativity mechanism is most interesting.

It is all very simple when a new object is created (we have xref:/midpoint/devel/prism/concepts/deltas/["add" delta]). Everything is new at that point, we know complete state of all the objects and everything is simple.
Therefore if the input is [a, b, c], then the output will be [ A, B, C ].

The things get more interesting when the object is modified (we have xref:/midpoint/devel/prism/concepts/deltas/["modify" delta]). Let's supposed that value "c" is removed from the input and values "d" and "e" are added to the input.
The mapping still transforms all the values individually.
Therefore it will be invoked five times: for both the old and new values.
However, when the expressions are evaluated midPoint remembers whether the input value was added, removed or whether it stayed the same.
MidPoint then applies the same operation to the value which is the output of an expression.
Therefore:

* Value "a" was not changed in the input.
Therefore transformed value "A" will be left unchanged in the output.

* Value "b" was not changed in the input.
Therefore transformed value "B" will be left unchanged in the output.

* Value "c" was removed from the input.
Therefore transformed value "C" will be removed from the output.

* Value "d" was added to the input.
Therefore transformed value "D" will be added to the output.

* Value "e" was added to the input.
Therefore transformed value "E" will be added to the output.

This may seem obvious when we know complete state of all objects and we are absolutely sure about it.
But that is not always the case.
MidPoint can work with resources that do not support transactions or any kind of locking.
Therefore what we know for sure is what has been changed (xref:/midpoint/devel/prism/concepts/deltas/[delta]). But we are not sure about the values that are present in target resource when we are about to apply the change (which may be several days later due to xref:/midpoint/reference/cases/approval/[approval process]). The good news is that this algorithm works also in these cases.
What the algorithm does is that it transforms the input delta of [-c, +d, +e] to output delta [-C, +D, +E].
This output delta can be applied even to a changed target value.
Let's suppose that there was a change on the target and the target value is now [X, B, C] instead of [A, B, C].
But when the [-C, +D, +E] is applied to the [X, B, C] value we still get the correct result of [X, B, D, E].

What is needed for this to happen is to have multi-value property with a large number of values that are changed quite often and where change happens by several asynchronous semi-independent channels.
You may think that a situation like this does not happen often.
But it does.
In identity management we have a lot of properties that behave exactly like this: groups, privileges, projects, tags, ...

Again, the description above mostly applies to xref:/midpoint/reference/expressions/expressions/script/[script expressions]. Expressions such as `asIs` have natural way how to deal with deltas and no value-by-value transformation is needed.
But again, non-script expressions such as `assignmentTargetSearch` will follow the same relativity principle: the search will get executed even for the removed valued so midPoint will know which assignment has to be removed.


=== Why are the expressions and conditions evaluated several times?

The short answer is: because of xref:/midpoint/reference/concepts/relativity/[relativity]. The long answer is indeed quite long and it is perhaps best explained using an example.
Let's have the same mapping as above that transforms lowercase characters to uppercase.
Now consider a situation when invar was changed from "a" to "b".
Simple thinking would suggest that we need to execute the expression for the input of "b", which will give us "B" and that's it.
But in the language of relativity a change from "a" to "b" actually means: remove value "a" and add value "b".
We can denote that as xref:/midpoint/devel/prism/concepts/deltas/[delta] [ -a, +b ]. Therefore the expression is invoked twice.
First invocation transforms value "a", so we know that we have to remove "A" from the output.
Second invocation transforms value "b", so we know that we have to add value "B" to output.
The result is delta [ -A, +B ]. This mechanism is designed to work well with multi-value properties (see above) and it often can be optimized for single-value properties.
Some of these optimizations are already implemented in midPoint, some are not (please consider a link:https://evolveum.com/services/[subscription] to make those optimizations complete).
Therefore midPoint may sometimes evaluate a value just to discard it moments later.
But the final result should be correct in any case.

Relativity is the reason for multiple execution of expressions, which is perhaps not that difficult to understand.
But what often comes as a surprise is that also mapping conditions are executed several times.
There is also a good reason for that and it is also based in relativity.
And once again it is best to explain using an example.
Therefore let's complicate our mapping a bit by adding a condition:

[source,xml]
----
<mapping>
    <source>
        <path>invar</path>
    </source>
    <source>
        <path>gate</path>
    </source>
    <expression>
        <script>
            <code>invar.toUpperCase()</code>
        </script>
    </expression>
    <target>
        <path>outvar</path>
    </target>
    <condition>
        <script>
            <code>gate == 'open'</code>
        </script>
    </condition>
</mapping>
----

Now the mapping is not supposed to produce any value if property gate in does not have value "open".
Simple thinking would suggest that midPoint will evaluate the condition once and if the result is false then the mapping is ignored.
But that would not work well in all cases.
E.g. if this is an xref:/midpoint/reference/expressions/mappings/outbound-mapping/[outbound mapping] to a tolerant resource attribute.
During the previous operation the inputs were invar=[b,c], gate=open and the target property already contained value [A].
So now the target property has values [A, B, C].
Now what happens if we change `gate` from open to closed? If the mapping is simply ignored then nothing would change on the resource.
The mapping would behave as if it is not there, therefore there is no output, therefore there is no output delta.
And as the target property is tolerant nothing is removed.
But that is not what we want.
The gate is closed.
The target should not have the values "B" and "C", should it?

Fortunately, midPoint is smart.
As everything in the midPoint even mapping conditions are relativistic.
MidPoint is relativistic and it knows that the value of gate changed from "open" to "closed".
Therefore what midPoint really does is that it executes the condition twice.
The condition is executed once for the old value of the `gate` variable which results in true.
Then it is executed for new value of `gate` variable, which results in `false`. Therefore midPoint knows that the condition has just changed from `true` to `false`. And therefore any values that this mapping produces are in fact to be _removed_ from the target.
In case that the value of invar is still [b,c], the output of the mapping is delta [-B, -C].
What that delta is applied to the target property value [A, B, C] the result is correct value [A].

Thanks to the relativity mapping conditions can be used to conditionally add values, but they work equally well for removing values.
This may seem overly complicated at the first sight.
But it has enormous benefits.
For example this approach allows easy automatic assignment of roles in xref:/midpoint/reference/expressions/object-template/[object template]. In that case the role assignment is the expression and the condition tells when the role should be assigned.
When that condition becomes `false` then the role is unassigned.
And no special mechanism was needed to implement this.
It is all given by the relativistic behavior of mappings.

In fact, this description is a bit simplified.
The real complexity is unleashed when there is a change in both source variables.
So now we have two deltas on the input that are supposed to produce single output delta.
And now imagine that there may be any number of input variables and that midPoint does not really know which of them are used in expression or condition.
We will not confuse the reader with a detailed explanation of the algorithm and we will refer extremely curious readers to midPoint source code.
The source code is the most precise documentation anyway.


== Replacing Values

See xref:practices/removing-values/[].

== Absolute Script Evaluation Mode

Relative evaluation mode of an expression as described above is the default behavior of mappings because it works well in most cases.
However, there may be cases when we need to process all the values and output a new set of values.
This may be needed because the values depend on each other, because we want to select just one of several values to map multi-value input to a single-value output or for other exotic cases.
In cases like this the mapping may be switched to _absolute_ mode:

[source,xml]
----
<inbound>
    <expression>
        <script>
            <relativityMode>absolute</relativityMode>
            <code>basic.determineLdapSingleAttributeValue(basic.getAttributeStringValues(account, 'dn'), 'uid', input)</code>
        </script>
    </expression>
    <target>
        <path>name</path>
    </target>
</inbound>
----

The `determineLdapSingleAttributeValue()` function above accepts a list of all LDAP attribute values as an input.
It will then select only one value and return that as an output.
This approach can be used to reduce typical LDAP multi-value attributes to a single-value midPoint properties.


== TODO

[TIP]
.TODO
====
This page may need to be expanded - especially with more examples and more detailed explanation.
However, documentation work is similar to the development work in that it takes time and that it needs funding. +
If you are midPoint link:https://evolveum.com/services/[subscriber], you can request that we complete this section and we will do that as soon as possible.
====


==  See Also

* xref:/midpoint/reference/expressions/introduction/[Mappings and Expressions]

* xref:../variables/[]

* xref:/midpoint/reference/expressions/mappings/mapping-evaluation-examples/[Mapping Evaluation Examples]