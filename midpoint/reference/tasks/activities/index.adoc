= Activities
:toc:
:page-since: "4.4"
:page-upkeep-status: green

== Introduction

Since the beginning of midPoint, a _task_ represented something that should be done, like importing
all accounts from a given resource. Such tasks could be created, executed, checked for the current
status and progress, and so on. Gradually, tasks grew rich in features: multi-thread and multi-node
processing, ability to suspend and resume (continuing where the work has stopped), various kinds
of statistics, and error-reporting and handling options.

Somewhere around midPoint 4.2, we have realized that a task is something that can have
a rich internal structure: it can consist of distinct "parts". An example is the reconciliation
task that typically consists of operation completion, resource objects reconciliation, and remaining
shadows reconciliation.

In midPoint 4.4 we finally have found a suitable conceptual model for the tasks and their work:
the activities.

== Activities

An _activity_ describes the real work that should be carried out. It can be either simple or composite.

_Simple activities_ consist of a single _action_, carried out on a set of input _items_ (zero, one,
or more ones). Typical examples are recomputation, import from resource, or iterative bulk action.

On the other hand, _composite activities_ consist of a set of other activities - again, either simple
or composite. Composite activities can be _predefined_ (like reconciliation or cleanup) or
_custom_. Note that composite activities do not have their own actions nor item sets. They are defined
solely by their constituent sub-activities.footnote:[This is not 100% true, as there may be
some auxiliary actions, like recording a starting timestamp for reconciliation, that are built into
the predefined composition logic. But those are really minor actions, not visible from the outside.
However, in the future we may be able to define custom composition logic for predefined or even for
custom composite activities.]

image::activity-categorization.png[alt="Activity categorization", width=600]

=== A Few Examples

==== Example 1: User recomputation - a simple activity with a set of input items

image::activity-user-recomputation.png[alt="User recomputation activity", width=400]

This activity runs a `recomputation` action over a set of all users.

==== Example 2: Non-iterative bulk action - a simple activity with no input items

image::activity-non-iterative-bulk-action.png[width=400,alt="Non-iterative bulk action"]

This activity runs a `nonIterativeScripting` action (i.e. non-iterative bulk action).
The bulk action does not expect any input items. It simply runs a provided Groovy script (in this case).

==== Example 3: Reconciliation - a (predefined) composite activity

image::activity-reconciliation.png[width=900,alt="Reconciliation activity"]

The reconciliation activity consists of a three sub-activities. They are partially dependent:
the third one (remaining shadows reconciliation) depends on the second one (resource objects reconciliation).

Each of the sub-activities has a different action, and a different item set.

==== Example 4: User recomputation + custom bulk action - a (custom) composite activity

image::activity-user-recomputation-with-custom-bulk-action.png[width=700,alt="User recomputation with bulk action"]

== Configuring the Activities

=== Configuring Simple and Predefined Composite Activities

A definition of a simple (or predefined composite) activity contains the following sections:

[%header]
[%autowidth]
|===
| Section | Meaning
| link:work[`work`] | The work that is to be done. Contains the definition of the activity and the item set.
| link:execution-mode[`executionMode`] | Defines the overall mode of execution: `full`, `preview`, `dryRun`, `none`,
`bucketAnalysis`.
| link:control-flow[`controlFlow`] | Items like prerequisites, preconditions, error handling strategy, and so on.
| link:distribution[`distribution`] | Distribution of the work executed as part of this activity into threads, buckets, and worker tasks.
| link:reporting[`reporting`] | How various aspects of activity execution are reported, using logging, tracing,
profiling, reporting, and so on.
| link:tailoring[`tailoring`] | Tailors the definition of individual sub-activities in a predefined composite activity.
|===

(More details are provided in the linked documents.)

=== Configuring Custom Composite Activities

In a current implementation, the custom composite activity definition contains just a single section:

[%header]
[%autowidth]
|===
| Section | Meaning
| `composition` | Defines the composite activity as a set of its constituent sub-activities.
|===

NOTE: There is a `defaultWorkDefinition` item in the `composition` section, but it is not supported yet.
It will be used to define a default work definition for the sub-activities. Neither we do not yet support
inheriting the non-functional aspects (`executionMode`, `controlFlow`, `distribution`, `reporting`) from
the composite to the sub-activities. Therefore, the sub-activities have to be fully defined, independently
of each other.

== Activities and Tasks

#TODO#

== Migration from 4.3 and Before

#TODO#

== GUI Support

#TODO#

== New Features

=== Cluster Auto-Scaling Capability

Distributed - a.k.a. multi-node - activities can be scaled up or down by starting or stopping worker tasks.
This scaling is appropriate when the distribution definition changes, e.g. number of worker tasks is increased
or decreased. It should be done also when the cluster configuration changes, e.g. nodes are added or deleted.

This up/down-scaling was present in midPoint since 3.8 (as an experimental feature) in the form of _workers
reconciliation_ process. In 4.4 the following changes were done:

1. The workers reconciliation process was improved and fixed:
 - It no longer closes superfluous workers - it suspends them instead, allowing resuming them when needed.
 - When suspending the workers, any unprocessed buckets are returned to the coordinator to process them
immediately by other workers. The same is true when the task stops for any other reason.
This eliminates lengthy "scavenging" process at the end of the processing.
 - When in scavenging phase, non-scavenger workers are not created. Only the scavengers are.
 - The whole reconciliation is now driven by node.operationalState (i.e. from repo) instead of
node.executionState (determined dynamically). So in case of unstable clusters or transition situations
the results should be more predictable.

2. New auto-scaling activity was created. It periodically scans for tasks that are autoscaling-enabled
and invokes workers reconciliation process on them, if the cluster state has changed in the meanwhile.
(Note that we currently do not support auto-scaling triggered by changes in activity distribution
definition. The user is responsible for reconciling the workers manually in that cases.)

=== Cluster-wide Thresholds

The xref:/midpoint/reference/tasks/thresholds/[threshold mechanism] before 4.4 was limited to a single node,
and the related policy rules counters were transient, so they did not survive midPoint node restarts.
There were other limitations as well.

Starting with 4.4, counters for policy rules are stored persistently in the respective task objects,
providing support for cluster-wide watching of policy rules thresholds, across task and node restarts.

=== Task Statistics Improvements

Flexible xref:reporting/execution-reports/[activity reports] were introduced:

- buckets processed,
- items processed,
- ConnId operations executed,
- internal operations executed.

Also, bucket size analysis mode is now available. It allows determining size of buckets before
real processing starts: either all buckets, or a (random or regular) sample of specified size.

The following information is now collected per individual activities (not per tasks):

- synchronization statistics,
- actions executed,
- work bucket management statistics.
