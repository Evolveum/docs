= Activities
:page-since: "4.4"
:page-upkeep-status: green

== Introduction

Since the beginning of midPoint, a _task_ represented something that should be done, like importing
all accounts from a given resource. Such task could be created, executed, checked for the current
status and progress, and so on. Gradually, tasks grew rich in features: multi-thread and multi-node
processing, ability to suspend and resume (continuing where the work has stopped), various kinds
of statistics, and error-reporting and handling options.

Somewhere around midPoint 4.2 we have realized that a task is actually something that can have
a rich internal structure: it can consist of distinct "parts". A typical example is reconciliation
task that typically consists of operation completion, resource objects reconciliation, and remaining
shadows reconciliation.

In midPoint 4.4 we finally found a suitable conceptual model for the tasks and their work:
the activities.

== Activities

An _activity_ describes the real work that should be carried out. It can be either simple or composite.

_Simple activities_ consist of a single _action_, carried out on a set of input _items_ (zero, one,
or more ones). Typical examples are recomputation, import from resource, or iterative bulk action.

On the other hand, _composite activities_ consist of a set of other activities - again, either simple
or composite. Composite activities can be _predefined_ (like reconciliation or cleanup) or
_custom_. Note that composite activities do not have its own actions nor item sets. They are defined
solely by their constituent sub-activities.footnote:[This is not 100% true, as there may be
some auxiliary actions, like recording a starting timestamp for reconciliation, that are built into
the predefined composition logic. But those are really minor actions, not visible from the outside.
However, in the future we may be able to define custom composition logic for predefined or even for
custom composite activities.]

image::activity-categorization.png[alt="Activity categorization"]

=== A Few Examples

==== Example 1: User recomputation - a simple activity with a set of input items

image::activity-user-recomputation.png[alt="User recomputation activity", width=400]

This activity runs a `recomputation` action over a set of all users.

==== Example 2: Non-iterative bulk action - a simple activity with no input items

image::activity-non-iterative-bulk-action.png[width=400,alt="Non-iterative bulk action"]

This activity runs a `nonIterativeScripting` action (i.e. non-iterative bulk action).
The bulk action does not expect any input items. It simply runs a provided Groovy script (in this case).

==== Example 3: Reconciliation - a (predefined) composite activity

image::activity-reconciliation.png[width=900,alt="Reconciliation activity"]

The reconciliation activity consists of a three sub-activities. They are partially dependent:
the third one (remaining shadows reconciliation) depends on the second one (resource objects reconciliation).

Each of the sub-activities has a different action, and a different item set.

==== Example 4: User recomputation + custom bulk action - a (custom) composite activity

image::activity-user-recomputation-with-custom-bulk-action.png[width=700,alt="User recomputation with bulk action"]

== Configuring the Activities

=== Configuring Simple and Predefined Composite Activities

A definition of a simple (or predefined composite) activity contains the following sections:

[%header]
[%autowidth]
|===
| Section | Meaning
| `work` | The work that is to be done. Contains the definition of the activity and the item set.
| `executionMode` | Defines the overall mode of execution: `full`, `preview`, `dryRun`, `none`,
`bucketAnalysis`.
| `controlFlow` | Items like prerequisites, preconditions, error handling strategy, and so on.
| `distribution` | Distribution of the work executed as part of this activity into threads, buckets, and worker tasks.
| `reporting` | How various aspects of activity execution are reported, using logging, tracing,
profiling, reporting, and so on.
|===

==== The Work Section

This section defines _what_ the activity should do (i.e. the action) and on what _items_ (the item set).
As of midPoint 4.4, the following items are supported:

[%header]
[%autowidth]
|===
| Item | Meaning | Parameter | Meaning | Default

.2+| `recomputation`
.2+| Recomputes specified objects
| `objects`
| What objects to recompute: given by `type`, `query`, `searchOptions`, `useRepositoryDirectly`, and `failedObjectsSelector` items - described below
| All of `AssignmentHolderType`

| `executionOptions`
| What options to use
| `reconcile`

| `import`
| Imports specified resource objects
| `resourceObjects`
| What resource objects to import: given by `resourceRef`, `kind`, `intent`, `objectclass`, `query`, `queryApplication`, `searchOptions`, and `failedObjectsSelector` - described below
| This is obligatory parameter.

| `reconciliation`
| Reconciles specified resource objects
| `resourceObjects`
| What resource objects to reconcile
| This is obligatory parameter.

| `asynchronousUpdate`
| Processes asynchronous updates for given resource objects (EXPERIMENTAL)
| `updatedResourceObjects`
| What resource objects to receive updates for
| This is obligatory parameter.

.3+| `liveSynchronization`
.3+| Processes live synchronization events for give resource objects
| `resourceObjects`
| What resource objects to synchronize
| This is obligatory parameter.
| `batchSize`
| If a positive value of `N` is specified here, live synchronization fetches
at most `N` records during each `provisioning.synchronize()` method execution - i.e. during
any live sync task run. (Currently, it leaves unprocessed changes for the next live sync
task run. This may change in the future.)

*USE WITH CARE.* This feature assumes that the connector provides LiveSync capability
with `preciseTokenValue` = `true`, i.e. that it assigns sync tokens to individual changes
"incrementally", so it can resume live sync operation on each individual change. This
can be the case of SQL connectors, but e.g. not for CSV or LDAP ones.
| 0
| `updateLiveSyncTokenInDryRun`
| Indicates if the LiveSync token should be updated when running in dry run mode.
If `false` (the default) then LiveSync will not update token to a new value, so it
will process objects fetched on the next run (either dry or normal). If `true`, it
will update the token, and therefore marks objects as processed.
| `false`

|===

=== Configuring Predefined Composite Activities

A predefined composite activity can contain the same sections as the simple activity definition.
They provide the default values for the embedded simple activities.

In addition to that, the definitions of individual sub-activities can be _tailored_ by providing explicit
definition. For example, the resource objects reconciliation sub-activity can be distributed in a way
different from the other sub-activities, defining buckets, worker tasks and worker threads.

[%header]
[%autowidth]
|===
| Section | Meaning
| `tailoring` | Tailors the activity definition by changing specification (execution mode,
flow of control, distribution) of existing sub-activities, or - in the future - by inserting
sub-activity or sub-activities before or after existing ones.
|===

=== Configuring Custom Composite Activities

In a current implementation, the custom composite activity definition contains just a single section:

[%header]
[%autowidth]
|===
| Section | Meaning
| `composition` | Defines the composite activity as a set of its constituent sub-activities.
|===

NOTE: There is a `defaultWorkDefinition` item in the `composition` section, but it is not supported yet.
It will be used to define a default work definition for the sub-activities. Neither we do not yet support
inheriting the non-functional aspects (`executionMode`, `controlFlow`, `distribution`, `reporting`) from
the composite to the sub-activities. Therefore, the sub-activities have to be fully defined, independently
of each other.

== Activities and Tasks



